## 栈

> [problem]
> 表达式算术求值

> [solution]
> 使用单调栈维护目前待计算的符号

Motivation: 一个表达式中，如果一个运算符既出现在前面，那它就应该先被计算完，将结果存在栈中供之后的表达式调用，因此维护一个单调栈，保持栈中符号优先级不减

$\text{opl } op \text{ opr}$
$\#$: 结束符

| 栈顶 \ 输入  | $+$ | $-$ | $\times$ | $/$ | $($         | $)$         | $\#$        |
| -------- | --- | --- | -------- | --- | ----------- | ----------- | ----------- |
| $+$      | >   | >   | !<       | !<  | <           | >           | >           |
| $-$      | >   | >   | !<       | !<  | <           | >           | >           |
| $\times$ | !>  | !>  | >        | >   | <           | >           | >           |
| $/$      | !>  | !>  | >        | >   | <           | >           | >           |
| $($      | <   | <   | <        | <   | <           | =           | $\emptyset$ |
| $)$      | >   | >   | >        | >   | $\emptyset$ | >           | >           |
| $\#$     | <   | <   | <        | <   | <           | $\emptyset$ | =           |
小于 $\to$ 先存起来，大于 $\to$ 弹栈，等于 $\to$ 抵消
$e$.$g$. $5\times (2+3)$
5, $\times$
5, $\times($
5 2, $\times ($
5 2, $\times ( +$
5 2 3, $\times (+$
5 6, $\times ($
5 6, $\times$
30

- 后缀表达式：运算符在式中出现的顺序恰为表达式的运算顺序；每个运算符和它之前出现且紧靠它的两个操作数构成一个最小表达式  // ab×cde/-f×+
- 后缀式求值：遇到操作数，进栈；遇到运算符，连续从栈中退出两个操作数，进行计算

- 中缀转后缀：读到操作数直接输出，而非存起来（后缀表达式的运算过程本身就带栈）
