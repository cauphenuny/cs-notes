## PDA

下推自动机： [[有穷自动机#NFA|NFA]] + 栈

直观理解：
$P=(Q,\Sigma,\Gamma,\delta,q_{0},F)$
- $Q$: 状态集
- $\Sigma$: 输入字母表
- $\Gamma$: 栈字母表
- $\delta$: 迁移函数
- $q_{0}\in Q$: 起始状态
- $F\subseteq Q$
$\delta$ 中的每一个迁移具有以下形式：$q_{i}\stackrel{a,x\to y}\longrightarrow q_{j}$ 表示：输入 $a$，出栈 $x$ ，入栈 $y$。$a$,$x$,$y$ 都可以是 $\varepsilon$

> [!warning]
> 如何知道栈已空？
> 新建一个特殊符号 `$` 表示栈底

数学定义

> [!def] PDA
> $(Q,\Sigma,\Gamma,\delta,q_{0},F)$
> $Q$,$\Sigma$,$\Gamma$ 定义见上文
> $\delta:Q\times\Sigma_{\varepsilon}\times\Gamma_{\varepsilon}\mapsto 2^{Q\times\Gamma_{\varepsilon}}$
> 注意：幂集 $2^{Q\times\Gamma_{\varepsilon}}$，所以是非确定的

> [!def] PDA 的格局 configuration
> $\langle q,\omega,\rho \rangle$，其中 $q\in Q,\omega \in\Sigma^*,\rho \in\Gamma^*$
> $q$: 当前状态
> $\omega$: 待处理输入字符串
> $\rho$: 栈中字符串

> [!def] 格局的改变/产生
> 称 $c_{1}=\langle q_{1},\omega_{1},\rho_{1} \rangle$ 产生 $c_{2}=\langle q_{2},\omega_{2},\rho_{2} \rangle$ 如果存在一个迁移 $q_{1}\stackrel{a,x\to y}\longrightarrow q_{2}$ 使得 $\omega_{1}=a\omega_{2},\rho_{1}=x\gamma,\rho_{2}=y\gamma$，记作 $c_{1}\vdash c_{2}$
> $\vdash^*$ 是 $\vdash$ 的传递闭包，$c\vdash^* c'\equiv \exists c_{i, }c\vdash c_{1},c_{1}\vdash c_{2},\dots c_{k-1}\vdash c_{k}$

> [!def] PDA 的接受
> $M=(Q,\Sigma,\Gamma,\delta,q_{0},F)$，$\omega$ 被 $M$ 接受，如果 $\exists q\in F,\rho \in\Gamma^*$, $\langle q_{0},\omega,\varepsilon \rangle\vdash \langle q,\varepsilon,\rho \rangle$
> 也可以定义成 $\langle q_{0},\omega,\varepsilon \rangle\vdash^*\langle q,\varepsilon,\varepsilon \rangle$ 只需要在前者接受后加一个清空栈的状态

## PDA 和 CFG 的等价性

> [!theorem]
> 一个语言是上下文无关的，当且仅当存在一台下推自动机识别它

- CFG $\to$ PDA:
	构造PDA如下：
	![[CFG2PDA.png]]
	对于 $u$ 长度大于一的情况，创建中间状态
	![[CFG2PDA2.png]]
	注意是反向压栈
	
	理解：读取输入匹配栈顶终结符，扩展栈顶变元
	
- PDA $\to$ CFG:
	先将 PDA 转换成满足以下条件的 PDA $M$：
	- 有唯一的接受状态 $q_{\text{accept}}$
	- 接受前清空栈
	- 每一个转移都推入/弹出一个符号，而且不同时做两个动作
	定义 CFG 如下：
	- G 的变元集 $V=\{ A_{pq}\mid p,q\in Q \}$ 起始变元为 $A_{q_{0}q_{\text{accept}}}$; $A_{pq}$ 表示从 $\langle p,\varepsilon \rangle$ （状态 $p$ 、空栈）到 $\langle q,\varepsilon \rangle$ 消耗的串，即：$\langle p,A_{pq},\varepsilon \rangle\vdash^*\langle q,\varepsilon,\varepsilon \rangle$
	- G 的终结符集合是 M 的字母表 Σ;
	- G 中的产生式包括如下3 类产生式:
		1. 考虑从状态 $p$ 到 $q$，如果中间栈不为空，那么一定有最开始入栈的和最后出栈的是同一个字符，设该字符是 $u$。如果 $p\stackrel{a,\varepsilon\to u}\longrightarrow r$ 和 $r\stackrel{b,u\to\varepsilon}\longrightarrow q$ （$p,r,q\in Q,a,b,\in\Sigma,u\in\Gamma$） 都是 $M$ 中的转移，则加入产生式 $A_{pq}\to aA_{rs}b$
		2. 如果存在中间空栈的状态 $r$，那么可以 $p\stackrel*\longrightarrow r\stackrel*\longrightarrow s$，加入产生式 $A_{pq}\to A_{pr}A_{rq} ,\quad\forall p,r,q$
		3. 如果初态和末态是同一个，那么消耗的串可以是 $\varepsilon$，加入产生式 $A_{pp}\to \varepsilon,\quad \forall p$
	可以通过两个方向的归纳法证明 $A_{pq}\stackrel*\Rightarrow x$ 当且仅当 $\langle p,x,\varepsilon \rangle \vdash^*\langle q,\varepsilon,\varepsilon \rangle$（两个方向分别在派生步数和计算次数上归纳）

直观理解一下 PDA 和 CFG 的共同点：
PDA 存储可能无上限信息的方式是放在栈上（因为 $\Sigma,\Gamma$ 都有限），入栈出栈同一个字符形成首尾呼应
CFG 应用某一个规则也是无上限的，而不断（不一定连续）应用同一个规则产生一个类似洋葱的结构，每一层产生的兄弟节点之间可以看成首尾呼应的

