## 定义

### 图灵规约和多一规约

> [!def] 多一规约 $P \leq_{m} Q$
> 存在可计算映射 $f$ 使得 $P(w)=Q(f(w))$ 就说 $P$ 多一规约到 $Q$ 记为 $P\leq _m Q$

为什么是“多一规约”？因为映射 $f$ 可以是一个多对一的映射

> [!theorem]
> 如果 $A\leq_{m} B$，且 $B$ 是可判定的，那么 $A$ 是可判定的

> [!proof]
> 构造图灵机对于输入 $w$ 计算 $f(w)$，然后判定 $f(w)$ 是否属于 $B$

> [!theorem]
> 如果 $A\leq_{m} B$，且 $B$ 是图灵可识别的，那么 $A$ 是图灵可识别的

> [!proof]
> 把判定 $f(w)$ 改成识别 $f(w)$

> [!def] 图灵规约 $P\leq_{T}Q$
> 若存在编码 $i$ 使得 $P=M_{i}^Q$（$M_{i}^{Q}:$[[特殊图灵机#神谕图灵机|神谕图灵机]]），那么就说语言 $P$ 图灵规约到 $Q$ ，记为$P \leq_{T}Q$

> [!theorem]
> $P\leq_{m} Q \implies P\leq_{T} Q$

> [!proof]
> 对于输入 $w$ ，计算 $f(w)$，然后查表（神谕带），获得 $Q(f(w))$

> [!theorem] 规约的复合
> $P \leq_{T} Q ,Q \leq_{T} S \implies P\leq_{T} S$

> [!proof]
> 由于 $Q\leq_{T}S$ 存在 $N^S$ 识别 $Q$，相应的有 $M^Q$ 识别 $P$
> 构造神谕图灵机 $M^S$ 识别 $P$.
> $M^S$ 能通过运行 $N^S$ 得到一条虚拟的神谕带 $Q$: 每次询问 $x \in? \,Q$ 时调用 $N^S$ 得到结果，从而模拟 $M^Q$ 识别 $P$.

> [!theorem]
> 如果 $A\leq_{T} B$，且 $B$ 是可判定的，那么 $A$ 是可判定的，称作 "$A$ 是相对于 $B$ 可判定的"
### 计算历史

> [!def] 计算历史
> 接受/拒绝历史：格局序列$C_{1},C_{2},\dots,C_{l}$，其中 $C_{l}$ 是接受/拒绝状态，且 $\forall i>1, C_{i}$ 是 $C_{i-1}$ 的合法结果

计算历史有限。如果 $M$ 在 $\omega$ 上不停机，则 $M$ 在 $\omega$ 上既没有接受也没有拒绝计算历史。
### 线性界限自动机

> [!def] 线性界限自动机 LBA
> 线性界限自动机 (LBA)是一种受到限制的图灵机，它不允许其读写头离开包含输入的带子区域。如果机器试图将它的读写头移出输入的两个端点，则读写头就保持在原地不动。

特点：
- 可用的存储空间为输入长度的常数倍（可以通过扩充带子字母表增加存储空间），故称为线性界限自动机
- 格局数目有限，但功能强大，$A_{DFA},E_{DFA},A_{CFG},E_{CFG}$ 的判定器都可以是 LBA

> [!theorem]
> 设 LBA $M$ 有 $q$ 个状态和 $g$ 个带子，对于长度为 $n$ 的带子，$M$ 有 $qng^n$ 个不同结局

> [!proof]
> 状态数 $q$ $\times$ 带子可能内容数 $ng^n$

---
## 应用

证明语言 $A$ 是可判定的：
- 直接设计算法（e.g. [[常见判定问题]]）
- 问题规约：将 $A$ 判定问题规约到另一个问题 $B$ ，若 $B$ 可判定，则 $A$ 可判定（反之不一定）；若 $A$ 不可判定，则 $B$ 不可判定。
### 多一规约和图灵规约
#### 停机问题 $\text{HALT}_{\text{TM}}$

> [!lemma]
> [[常见判定问题#图灵机接受问题 $A_{ text{TM}}$]] 不可判定

> [!theorem]
> $\text{HALT}_{\text{TM}}=\{ \langle M,\omega \rangle| M是一个图灵机，且对于输入\omega 停机 \}$  不可判定

> [!proof]
> 图灵规约 A 到 Halt
> 构造 $M^\text{HALT}$ ，下简写为 $M^H$:
> 1. 对于输入 $\langle M,\omega \rangle$，查神谕带得知 $\langle M,\omega \rangle$ 是否属于 $\text{HALT}$，若不属于则拒绝，反之运行下一步
> 2. 运行 $M(\omega)$，根据 $M(\omega)$ 结果（必定停机）选择结束状态。

也可以不显式使用规约，直接构造一个图灵机器 $M$ ，由假设 $\text{HALT}_{\text{TM}}$ 可判定可知存在 TM $N$ 判定它，在 $M$ 中使用该机器可以得到判定 $A_{\text{TM}}$ 的机器，与 $A_{\text{TM}}$ 不可判定矛盾。

![[Pasted image 20250429192005.png]]

#### 空性问题 $E_{\text{TM}}$

> [!theorem]
> $E_{\text{TM}}=\{ \langle M \rangle|M 是一个图灵机，且L(M)=\varnothing \}$ 不可判定

> [!proof]
> 规约到 $A_{\text{TM}}$ 问题
> 设图灵机 $M_{E}$ 判定 $E_{\text{TM}}$
> 对于输入 $\langle M,\omega \rangle$，直接把 $M$ 送到 $M_{E}$，再得到 $L(M)$ 非空的结果之后仍可能会不停机
> 输入一个修改之后的图灵机 $M_{\omega}$，其中 $M_{\omega}$ 在输入串 $w\neq \omega$ 时拒绝，仅当 $w=\omega$ 时继续算 $M(\omega)$，所以 $M_{\omega}$ 的语言不空当且仅当 $M_{\omega}$ 接受 $\omega$，也代表着 $M$ 接受 $\omega$
> 把这个图灵机 $M_{\omega}$ 送进 $E_{\text{TM}}$ 即可判定 $A_{\text{TM}}$

#### 图灵接受语言的正则性 $\text{REGULAR}_{\text{TM}}$

> [!theorem]
> $\text{REGULAR}_{\text{TM}}=\{ \langle M \rangle|M是图灵机，L(M) 是正则语言 \}$ 不可判定

> [!proof]
> 设图灵机 $M_{R}$ 判定 $\langle M \rangle$ 是否识别正则语言
> 下面构造判定 $A_{\text{TM}}$ 的图灵机 $S$:
> 对于输入 $\langle M,w \rangle$ ，
> 1. 构造图灵机 $M_{2}$="在输入 $x$ 上
> 	1. 如果 $x$ 具有形式 $0^n 1^n$形式，则接受
> 	2. 反之在 $w$ 上运行 $M$，若 $M$ 接受 $w$ 则接受
> 2. 在输入 $\langle M_{2} \rangle$ 上运行 $M_{R}$
> 3. 若 $M_{R}$ 接受，则接受，反之拒绝
> note: $M_{2}$ 在 $M$ 接受 $\omega$ 的时候接受 $\Sigma^*$，反之接受 $0^n 1^n$，而 $0^n 1^n$ 是非正则的

#### 相等问题 $\text{EQ}_{\text{TM}}$

> [!theorem]
> $\text{EQ}_{\text{TM}}$ 既不是图灵可识别的，也不是补图灵可识别的

> [!proof]
> 根据多一规约的定义，$A\leq_{m}B$ 等价于 $\overline{A}\leq_{m}\overline{B}$，而 [[计算基础概念#^c061e8|$\overline{A_\text{TM}}$ 不可识别]]，所以只要证明 $A_{\text{TM}}\leq_{m} \overline{\text{EQ}_{\text{TM}}}$ 就能说明 $\text{EQ}_{\text{TM}}$不是图灵可识别的。
> - $A_{\text{TM}}\leq_{m}\overline{\text{EQ}_{\text{TM}}}$
> 	规约函数 $f$:
> 	$F=$"对于输入 $\langle M,w \rangle$
> 	1. 构造两个机器 $M_{1}$ 和 $M_{2}$，其中：
> 		$M_{1}=$ '对于任意输入，拒绝'
> 		$M_{2}=$ '对于任意输入，运行 $M(w)$，若接受，则接受'
> 	2. 输出 $\langle M_{1},M_{2} \rangle$"
> 类似地，证明 $A_{\text{TM}}\leq_{m}\text{EQ}_{\text{TM}}$ 可以证明 $\text{EQ}_{\text{TM}}$ 不是补图灵可识别的。
> - $A_{\text{TM}}\leq_{m}\text{EQ}_{\text{TM}}$
> 	规约函数 $g$:
> 	$G=$"对于输入 $\langle M,w \rangle$
> 	1. 构造两个机器 $M_{1}$ 和 $M_{2}$，其中：
> 		$M_{1}=$ '对于任意输入，接受'
> 		$M_{2}=$ '对于任意输入，运行 $M(w)$，若接受，则接受'
> 	2. 输出 $\langle M_{1},M_{2} \rangle$"

> [!theorem]
> $E_{TM}$ 不可规约到 $A_{\text{TM}}$

> [!proof]
> $E_{\text{TM}}$ 是补图灵可识别的（考虑一个并行验证所有串的机器）
> 如果 $E_{\text{TM}}$ 可以规约到 $A_{\text{TM}}$，那么 $E_{\text{TM}}$ 同时属于 RE 和 coRE，那么它可判定
> 又因为 $A_{\text{TM}}$ 可以规约到 $E_{\text{TM}}$，所以 $A_{\text{TM}}$ 可判定，矛盾。
> 所以 $E_{\text{TM}}$ 不可规约到 $A_{\text{TM}}$

---
### 计算历史规约

> [!theorem]
> $A_{LBA}$ 可判定

> [!proof]
> 构造判定 $A_{LBA}$ 的图灵机如下：
>  S = “对于输入 $⟨M,ω⟩$, 其中 $M$ 是 LBA，$ω$ 是串:
>  1. 在输入 $ω$  上运行 $M$ , 总共进行 $qng^n$ 步，或者 (对于不足 $qng^n$ 步的情况) 直到它停机；
>  2. 如果 M 停机，则它接受时接受，它拒绝时拒绝。如果 M 还未停机 (此时路径中含有环)，则拒绝。”

> [!theorem]
> $E_{LBA}$ 不可判定

> [!proof]
> 构造 $A_{TM}$ 到 $E_{LBA}$ 的计算历史规约
> 构造一个可以识别 $\langle M,\omega \rangle$ 的接受计算历史 $x$ 的 LBA $B$.
> 	把 $\langle M,\omega \rangle$ 硬编码到 $B$ 中，然后在串 $x$ 中左右跳，验证[[规约#计算历史]]的三个条件
> 设图灵机 $R$ 判定 $E_{LBA}$
> 下面构造 TM $S$ 判定 $A_{\text{TM}}$
> 1. 根据 $\langle M,\omega \rangle$ 构造 LBA $B$ 
> 2. 在 $\langle B \rangle$ 上运行 $R$.
> 3. $R$ 接受，则拒绝，反之接受
> note: $L(B)=\varnothing\Leftrightarrow$ $M$ 在 $\omega$ 上没有接受计算历史 $\Leftrightarrow$ $M$ 不接受 $\omega$

![[Pasted image 20250429202029.png]]

> [!theorem]
> $\text{ALL}_{CFG}=\{ \langle G \rangle|G 是CFG，L(G)=\Sigma^* \}$ 不可判定

> [!proof]
> 规约 $A_{\text{TM}}$
> 对于图灵机 $M$ 和输入 $w$ ，构造一个 CFG $G$ ，使得它能派生所有串，当且仅当 $M$ 不接受
> $w$。这个串应该是 $M$ 在 $w$ 上的接受计算历史的补集。
> 不满足接受计算历史的三个条件：
> - 不以 $C_{1}$ 开始
> - 不以接受格局结束
> - 在 $M$ 的规则下，某个 $C_{i}$ 不派生 $C_{i+1}$
> 设计一个 PDA 非确定性的检查3个条件
> trick：奇数格局向前写，偶数格局向后写，方便PDA弹栈比较
> ![[IMG_4B79666C3B58-1.jpeg]]

> [!def] 波斯特对应问题 PCP
> 将一组骨牌进行排列（允许重复），使得顶部符号和底部符号相同，这样的匹配是否存在？

> [!example]
> $\left\{  \left[ \dfrac{b}{ca} \right],\left[ \dfrac{a}{ab} \right],\left[ \dfrac{ca}{a} \right],\left[ \dfrac{abc}{c} \right]  \right\}$ 的一个匹配：
> 
> $\left[ \dfrac{a}{ab} \right]\left[ \dfrac{b}{ca} \right]\left[ \dfrac{ca}{a} \right]\left[ \dfrac{a}{ab} \right]\left[ \dfrac{abc}{c} \right]$

> [!theorem]
> 波斯特对应问题不可判定

> [!proof]
> 构造一组骨牌表示转移，将 $A_{\text{TM}}$规约到波斯特对应问题
> 起始状态 $\left[ \dfrac{\#}{\#q_{0}w_{2}w_{2}\dots w_{n}} \right]$
> - 若 $\delta (q,a)=(r,b,R)$ 则放入 $\left[ \dfrac{qa}{br} \right]$
> - 若 $\delta (q,a)=(r,b,L)$ 则放入 $\left[ \dfrac{cqa}{r c b} \right]$
> - 对于每一个 $a \in T$ 放入 $\left[ \dfrac{a}{a} \right]$
> - 放入 $\left[ \dfrac{\#}{\#} \right]$ 和 $\left[ \dfrac{\#}{\sqcup \#} \right]$（分割格局，后者能模拟从无限多的空格中取一个出来）
> - 对于每一个 $a \in T$放入 $\left[ \dfrac{aq_\text{accept}}{q_{\text{accept}}} \right],\left[ \dfrac{q_{\text{accept}}a}{q_{\text{accept}}} \right]$，吃掉 accept 状态周围的字符
>   ![[IMG_A17CC47386E5-1.jpeg]]
> - 放入 $\left[ \dfrac{q_{\text{accept}}\#\#}{\#} \right]$表示最终匹配
> 	![[IMG_A17CC47386E5-2.jpeg]]
> 如何保证只有起始骨牌开始匹配？
> ![[IMG_A17CC47386E5-3.jpeg]]


## 证明可判定性的一般方法

证明一个问题（语言）可判定，需要找到判定这个语言的判定器。

• 证明一个问题（语言）不可判定，若问题抽象程度很高，可使用对角化方法直接证明（例如：[[TCS-assignment3.pdf|习题4.12]]）；除此之外，一般可以先假设该问题C 可判定，然后找到从一个已知不可判定的问题D 到问题C 的归约过程，形成矛盾。（e.g. [[TCS-assignment4.pdf|习题5.1]]）

• 这就要求掌握常见不可判定语言作为归约起始，如$A_{\text{TM}}$、$E_{\text{TM}}$、$\text{ALL}_{\text{CFG}}$ 等等。

• 归约过程通常也采用定义判定器的方法呈现：定义一个判定器，其中模拟假定存在的判定问题C 的判定器运行，输出问题D 的正确结果，以此说明问题D可判定。

• 证明和图灵机性质有关的问题时经常使用“定义新图灵机，并将其描述作为输入模拟另一个图灵机运行”的方法。定义的新图灵机本身可能不停机，但定义的目的不是为了运行该图灵机，而只是获取它的描述。