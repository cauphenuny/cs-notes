引入："反编译打印"

构造一个算法 $Q$，输入串 $\omega$，输出一个能打印 $\omega$ 的图灵机转移函数编码 $\langle P_{\omega} \rangle$

> [!def] 图灵机 $P_{\omega}$
> $\forall \omega \in \Sigma^*$，$P_{\omega}$ 定义如下
> 对于任意输入 w
> 1. 抹去输入 w
> 2. 写下 $\omega$
> 3. 停机

> [!def] 图灵机 $Q$
> 对于任意输入 $\omega$
> 1. 构造图灵机 $P_\omega$
> 2. 计算并输出 $P_{\omega}$
> 3. 停机

$Q$：输入 $\omega$，输出 $\langle P_{\omega} \rangle$，是 [[计算基础概念#可计算函数类|可计算函数]] $q: \Sigma^* \to \Sigma^*, \omega \mapsto \langle P_{\omega} \rangle$ 对应的图灵机

> [!def] 图灵机 $B$
> 输入 $\omega$，运行得到 $\langle P_{\omega} \rangle\omega$
> 当检测出 $\omega$ 也是一个图灵机编码时， 把 $\langle P_{\omega} \rangle\omega$ 和 $\omega$ 合并成一个新图灵机的编码。
> 新图灵机依次执行两段编码，即添加第一段编码的停机状态到第二段编码的起始状态的迁移，并把它俩变成普通状态

$B$ 是一个取定的固定图灵机

> [!def] 图灵机 $A$
> $A := P_{\langle B \rangle}$

> [!def] 图灵机 $\text{SELF}$
> $\text{SELF}:=(A,B)=(P_{\langle B \rangle},B)$
> $(A,B)$: 一个先执行 $A$ 再执行 $B$ 的图灵机，前者输出是后者输入

SELF 的执行结果：
- 执行 $A$，即 $P_{\langle B \rangle}$ 后输出 $\langle B \rangle$
- 执行 $B$ 之后结果为：输出 $\langle P_{\langle B \rangle} \rangle\langle B \rangle$，即 $\langle (A,B) \rangle$，即 $\langle \text{SELF} \rangle$

直观理解：先 {执行$A$ ，即打印 $\langle B \rangle$} ，然后 {执行 $B$ ，即把打印 $\langle B \rangle$ 的过程序列化，加在 $\langle B \rangle$ 前面}，输出的内容就和执行的内容一样了

> [!example]
> 写下面这段话：“看到你刚才写的东西了吗？在它前面添加一行，在这一行里先写下‘写下面这段话：’，加个左双引号，再把你之前看到已经写出来的东西再写一遍，最后加右双引号。”
> 看到你刚才写的东西了吗？在它前面添加一行，在这一行里先写下‘写下面这段话：’，加个左双引号，再把你之前看到已经写出来的东西再写一遍，最后加右双引号。

| 人类语言部分                | 对应图灵机部分                                                    |
| --------------------- | ---------------------------------------------------------- |
| “写下面这段话：……”           | 图灵机 $A:=P_{⟨B⟩}$：写下描述 ⟨B⟩                                  |
| “看到你刚才写的东西了吗？”        | 图灵机 **B**：接收前面输出作为输入，对其操作                                  |
| “在它前面添加一行……”          | 图灵机 **B** 的逻辑：合并前一段编码（来自 A）和当前编码（自己的）                      |
| “再把你之前看到已经写出来的东西再写一遍” | 图灵机 **B** 使用 $\langle P_{\omega} \rangle \omega$ 构造新的图灵机编码 |
| “最后加右双引号。”            | B 构造完毕，得到完整图灵机 $\langle (A,B) \rangle$，即 ⟨SELF⟩            |

> [!theorem] 递归定理
> 设 $T$ 是计算函数 $t: \Sigma^* \times \Sigma^* \to \Sigma^*$的图灵机，则存在计算函数 $r: \Sigma^* \to \Sigma^*$ 的一个图灵机 $R$ 使得 $\forall w, r(w)=t(\langle R \rangle,w)$

为了制造一个能得到自己的描述，并用它进行计算的图灵机，只需要构造一个有两个输入参数的图灵机 T，它计算了一个 2 元可计算函数。然后递归定理就产生了一个新的机器 R, 它和 T 一样运行, 只是 R 的描述被自动地装在 T 中。

> [!proof]
> 构造以下图灵机（$\text{input}\longrightarrow \text{output}$）
> 1. $P_{\omega}: w \longrightarrow \omega  \# w$
> 2. $Q: \omega \longrightarrow \langle P_{\omega} \rangle$，即 $q(\omega)=\langle P_{\omega} \rangle$
> 3. $B: \langle M_{1},M_{2} \rangle\# w \longrightarrow \langle P_{\langle M_{1},M_{2} \rangle}, M_{1},M_{2} \rangle\#w$
> 4. $A:=P_{\langle B,T \rangle}$
> 5. $R:=(A,B,T)$
> 对于输入 $w$，$R$ 每一步的执行结果：
> $$ \begin{align} w & \stackrel A\longrightarrow \langle B,T \rangle\#w \\  & \stackrel B\longrightarrow\langle P_{\langle B,T \rangle},B,T \rangle\#w=\langle R \rangle\#w \\ & \stackrel T\longrightarrow t(\langle R \rangle,w) \end{align} $$
> 所以 $r(w)=t(\langle R \rangle,w)$ 证毕

> [!theorem] 递归定理的不动点形式
> 设可计算函数 $g$，则存在图灵机 $F$ 使得 $g(\langle F \rangle)$描述了一个和 $F$ 等价的图灵机。（如果 $g(\langle F \rangle)$ 不是合法编码，则直接拒绝）

$G$ 是总停机的，$F$ 可以不停机

> [!proof]
> 构造图灵机 $F=$"对于输入 $w$:
> 1. 由递归定理得到自己的一个描述 $\langle F \rangle$
> 2. 计算 $g(\langle F \rangle)$ 得到图灵机 $G$ 的描述
> 3. 在输入 $w$ 上模拟 $G$"
> 
> 那么有 $\langle F \rangle$ 和 $g(\langle F \rangle)=\langle G \rangle$ 等价
> > [!example]
> > 递归定理中的 $t:\Sigma^*\times\Sigma^*\to\Sigma^*$ 是 $t(x,y)=u(g(x),y)$ 其中 $u$ 是[[特殊图灵机#通用图灵机|通用图灵机]] 计算的函数
> > $R$ 就是要构造的 $F$.

[[lambda 演算]]有类似的不动点构造证明

另一个应用递归定理的例子

> [!example]
> 用递归定理描述 $\text{SELF}$:
> $\text{SELF}=$“对于任意输入
> 1. 得到自己描述 $\langle \text{SELF} \rangle$
> 2. 打印 $\langle \text{SELF} \rangle$
> 
> 等价描述：先建立有二元输入的机器 $T=$"对于输入$\langle x,w \rangle$，打印 $x$，停机"，然后应用递归定理得到 $R$

更一般地，在设计任意的一个图灵机 $M$ 时，可以在算法描述中加入：“通过递归定理得到自己的描述”，一旦得到描述之后，就可以像其他已计算的值一样使用这个描述。

具体是如何应用递归定理的呢？先将这个“自己的描述”作为一个占位符，定义一个二元的可计算函数，然后应用递归定理将这个二元函数转换为一元的，占位符填入自己的描述，就像上面的几个例子一样。

> [!example]
> C++ 中的递归 lambda，这个 self 就是占位符:
> ```cpp
> auto recursive = [](auto self, int param) {
> 	if (!param) return 1;
> 	return param * self(self, param - 1);
> };
> recursive(recursive, arg);
> ```

但这个例子中并没有把二元函数转换为一元，接下来使用 [[lambda 演算#^2a6c47|$\lambda$演算：y组合子]] 构造一个一元函数

```cpp
template<typename F> 
struct y_combinator {
	F func;
	auto operator()(auto... args) { return func(*this, args...); }
}

auto fact = y_combinator([](auto self, int param) -> int {
	if (!param) return 1;
	return param * self(param - 1);
});
fact(5); // 120
```

> [!def] 最小图灵机
> 如果 $M$ 是一个图灵机，所有与 $M$ 等价的图灵机没有长度比 $\lvert \langle M \rangle \rvert$ 更小的就成 $M$ 是最小的。
> $\text{MIN}_{\text{TM}}=\{ \langle M \rangle\mid M\text{ 是一个最小图灵机} \}$

> [!theorem]
> $\text{MIN}_{\text{TM}}$ 不是图灵可**识别**的

> [!proof]
> 设有枚举器 $E$ 枚举 $\text{MIN}_{\text{TM}}$
> 构造图灵机 $C=$"对于输入 $w$ ：
> 1. 由递归定理得到自己描述 $\langle C \rangle$
> 2. 运行 $E$ 直到一个比自己的描述更长的机器 $D$ 出现
> 3. 在输入 $w$ 上模拟 $D$
> 因为 $\text{MIN}_{\text{TM}}$ 是无限的（若有限，则一直能加新的图灵机进去），所以 $E$ 的序列必含有比 $C$ 描述更长的图灵机，因此第二步一定停止，但 $C$ 与 $D$ 等价且长度 $C<D$，与 $D\in\text{MIN}_{\text{TM}}$ 矛盾，所以不存在枚举器 $E$.
