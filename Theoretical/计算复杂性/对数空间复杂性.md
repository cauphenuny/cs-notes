> [!def] L, NL
> 回忆 [[空间复杂性#^4a1ca2|SPACE,NSPACE]]
> $\text{L}=\text{SPACE}(\log n)$
> $\text{NL}=\text{NSPACE}(\log n)$

^22da65

> [!example]
> PATH 属于 NL

> [!proof]
> 非确定性地考虑下一步走哪条边，记录当前节点和计数器，如果节点是目标节点则接受，如果计数器超过节点数量则拒绝，空间复杂度 $\log$

---

> [!def] 关于规约封闭
> $\Omega$ 关于 $\leq_{1}$ 封闭：
> $\forall L_{1},L_{2},L_{1}\in\Omega, L_{1}\leq_{1}L_{2}\implies L_{2}\in \Omega$

---

> [!def] 对数空间规约
> $A\leq_{L} B$:
> $A$ 通过对数空间可计算函数 $f$ 可以规约到 $B$。
> 对数空间可计算函数：$f: \Sigma^*\to\Sigma^*$，只读输入，**只写输出**，读写工作带，工作带包含 $O(\log n)$ 个符号

> [!def] NL-完全
> $B$ 是 NL-完全的，如果 
> 1. $B \in\text{NL}$
> 2. $\forall A\in\text{NL},A\leq_{L}B$

> [!theorem]
> $A\leq_{L}B,B\in L \longrightarrow A\in L$

> [!proof]
> 类似[[多项式时间复杂性#^63c469|多项式时间规约]]的证明思路，但是这里不能直接存 $f(w)$，因为输出带符号数可能不是 $\log$ 的
> 按需产生：如果计算 $B$ 的机器需要，才调用 $A$ 机器产生 $f(w)$ 的第 $i$ 位，空间复杂度只跟工作带有关，是 $\log$ 级别的。

> [!theorem]
> PATH 是 NL-完全的

> [!proof]
> 在对数空间内输出识别 NL 中某语言$L$ 的机器 $M$ 的每个格局（不超过$c\log n$ 个字符），以及两个格局之间的转移

> [!corollary] 推论
> $\text{NL}\subseteq\text{P}$

> [!proof]
> $\forall L\in\text{NL},L\leq_{L}\text{PATH}$
> 对数空间规约在多项式时间中运行，所以 $\forall L\in\text{NL},L\leq_{p}\text{PATH}$，而 $\text{PATH}\in\text{P}$，所以 $\text{NL}\subseteq\text{P}$
> > [!lemma] 引理： $\text{PATH}\in\text{P}$
> > 对于图$\langle V,E \rangle,n\coloneqq \lvert V \rvert,m\coloneqq \lvert E \rvert$，从起点开始标记染色，标记哪些节点能到，标记一轮复杂度为 $m$，标记次数不超过 $n$（无新节点就停止），根据目标节点是否染色判断是否存在PATH

---

> [!theorem]
> $\text{NL}=\text{coNL}$

> [!proof]
> 思路：证明 $\overline{\text{PATH}}\in\text{NL}$
> 设 $m$ 是节点数，找是否 $s\longrightarrow t$ 有 PATH
> 维护 $c_{i}$ 表示从起点开始不超过 $i$ 步能到达的节点个数，每次从 $c_{i}$ 计算 $c_{i+1}$ 时，非确定地选择 $c_{i}$ 中具体有哪些节点，非确定地找到路径，如果非法则拒绝。
> 成功计算出 $c_{1},c_{2},\dots,c_m$ 的计算路径可能有很多，但 $c_{i}$ 的值都是相等的，无所谓
> 计算完 $c_{i}$ 之后，类似地非确定的找到 $c_{m}$ 中具体是哪些点，猜错了拒绝，如果 $t$ 在集合中也拒绝，只有成功地选了 $c_{m}$ 个点，并且 $t$ 不在集合中才接受，表示不存在 $s\longrightarrow t$ 路径。
> 计算过程中只需要存当前的 $i$ 和 $c_{i}$，空间复杂度 $O(\log n)$

$\text{L}\subseteq\text{NL}=\text{coNL}\subseteq\text{P}\subseteq\text{NP}\subseteq\text{PSPACE}$
