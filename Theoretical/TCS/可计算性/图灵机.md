描述图灵机算法的三个层次：
1. 形式化描述：基于形式化的 7 元组定义，详尽地给出图灵机的状态和迁移函数
2. 实现描述：使用日常语言描述图灵机的动作，如怎样移动读写头，怎样修改带子的内容等
3. 高层次描述：使用日常语言，但忽略实现的细节，不再提及机器是如何管理带子和读写头的

> [!example] 实现描述
> 设A= {⟨G⟩|G是连通无向图}, 其中 ⟨G⟩是对无向图 G 的一种编码，证明A可被图灵机识别。
> 
> 令M是如下定义的图灵机，它接受上面的语言A.
> M = “输入是图 G 的编码 ⟨G⟩:
> 1. 选择 G 的第一个顶点，并标记之；
> 2. 重复下列步骤，直到无新的顶点可标记；
> 3. 对 G 的任一顶点，如果能通过一条边将其连到另一个已被标记的顶点，则标记该顶点；
> 4. 扫描 G 的所有顶点，确认它们是否都已做了标记。如果是，则接受，否则拒绝。”

## 形式化定义

形式化定义：

> [!def] 图灵机
> 图灵机是一个 7 元组 $(Q, Σ, Γ, δ, q_{0}, q_{\text{accept}}, q_{\text{reject}})$, 其中
> - $Q$ 是一个有限集合，称为状态集；
> - $Σ$ 是一个输入字母表, 不包括特殊空白符号 ⊔；
> - $Γ$ 是带子的字母表，且 $⊔∈Γ$, $Σ ⊆Γ$；
> - $δ : Q ×Γ →Q ×Γ ×{L, R}$是迁移函数;
> - $q_0 ∈Q$ 是起始状态；
> - $q_{\text{accept}}$ ∈Q 是接受状态;
> - $q_{\text{reject}}$ ∈Q 是拒绝状态，且 $q_{\text{accept}}\neq q_{\text{reject}}$.


- 实现/高层次描述中，【输入格式】（即使是“对于输入串w”；更多信息见“图灵机（3）”页） 、【接受/拒绝条件】（即使是“若（另一个图灵机）接受，则接受；若拒绝，则拒绝”）需写清楚，不可省略，这些都是良好定义的一部分。在实现层次描述中，还需写清【带子读写方式】、【读写头移动方式】等实现细节。

-  除3.8 c. 明确要求实现层次描述外，其它题目未要求具体描述形式。但在证明“语言（不）可识别/判定”等可用构造图灵机方法的场合下，建议规范使用图灵机的高层次描述来定义图灵机。避免只说“x 问题和y 问题等价”或“因为x 问题可判定，y 问题也可判定”，而是直接定义一个其中模拟已有图灵机运行的、包括明确的接受/拒绝条件的新图灵机。


## 输入格式

图灵机的定义使得其可以将任意Σ∗ 中的字符串作为输入，并产生接受/拒绝/不停机三种结果之一。在图灵机描述中，说明【输入格式】，就暗含了【在运行开始时检查输入是否符合格式，如不符合则拒绝】的步骤，不用额外在描述中单独再写一步。

例如如果存在识别 $\text{EQ}_{\text{CFG}}$ 的图灵机（当然，[[TCS-assignment4.pdf|练习5.1]] 和5.2 已经表明它不是图灵可识别的），这个图灵机的描述可以写作：

$M=$“对于输入$⟨G, H⟩$，其中 $G, H$ 为CFG：⋯⋯”
这样，如果输入串不符合 $⟨G, H⟩$ 格式，将会自动拒绝。

但是，如果在定义识别$\overline{\text{EQ}_\text{CFG}}$ 的图灵机时，规定这一输入格式，图灵机也会拒绝任何不符合该格式的字符串。

但是语言的补集是相对于 $Σ^*$ 的，如果$\overline{\text{EQ}_\text{CFG}}$ 中只包含输入格式为 $⟨G, H⟩$ 的串，任何不满足该格式的串都应该在$\overline{\text{EQ}_\text{CFG}}$ 中。

所以， $\overline{\text{EQ}_\text{CFG}}$ = ${w | w ∈ Σ∗且w不满足⟨G, H⟩的格式，其中G和H都是CFG}$ $∪$ ${⟨G, H⟩ | G和H都是CFG，且L(G) \neq L(H)}$