## 程序分析技术

- 流分析
	- 控制流分析
	- 数据流分析

- 依赖分析
	- 控制依赖
	- 数据依赖

- 指针/别名分析

---

基本块活跃变量分析:

倒序遍历块中的每一个instruction，对于每一个 $i:x=y+z$，设置：
1. 将符号表中的 $x$, $y$, $z$ 的活跃性信息和后续使用信息关联到指令 $i$ 
2. 设置 $x$ 为不活跃、无后续使用
3.  设置 $y$ $z$ 为活跃，下一次使用设置为 $i$ 

注意 2 3 顺序不能换，可能 $y$ / $z$ 就是 $x$ .

---

求基本块控制节点：

核心：初始化 `dom[root]=root, dom[others]=all`，不断求闭包 `dom[n]=intersect(dom[p] for p in n.pred)`

```python
class Node:
	@property
	def pred() -> set[Node]: ...

def compute_cominator(nodes: set[Node], root: Node) -> dict[Node, set[Node]]:
	dom: dict[Node, set[Node]] = {}
	for n in nodes - {root}: # 全集去掉根节点
		dom[n] = nodes
	dom[root] = {root}
	change: bool = True
	while change:
		change = False
		for n in nodes - {root}:
			d = nodes # 控制节点集
			for p in n.pred: # n 的所有前驱
				d = d.intersection(dom[p])
			d = d.union({n})
			if dom[n] != d:
				dom[n] = d
				change = True
	return dom
```

---
循环：**单入口** 的 **强连通分量**

入口点(entry point or loop header )唯一，且dominate所有循环中其它点

![[Pasted image 20260111112750.png]]

这个强连通分量不是循环

流图中识别循环的条件：流图的结点集合L，
若
1. 在L中有一个被称为循环入口（loop entry）的结点，它是唯一的其前驱可能在L之外的结点
2. L中的每个结点都有一个到达L的入口结点的非空路径，且该路径全部在L中

寻找循环的算法（根据回边）

```python
class Edge:
	source: Node
	sink: Node

class Graph:
	nodes: set<Node>
	edges: set<Edge>

class Stack(Generic[T]):
	def push(self, item: T): ...
	def pop(self) -> T: ...
	def __len__(self) -> int:
		return self.size

def construct_loop(graph: Graph, back_edge: Edge):
	sink = back_edge.sink
	src = back_edge.source
	stack = Stack()
	loop = {sink}
	loop.insert(src)
	stack.push(src)
	while not stack:
		n = stack.pop()
		for p in n.pred:
			if not p in loop:
				loop.insert(p)
				stack.push(p)
	return loop
```

为什么满足条件1: 集合中的点的所有前驱都会被加在集合中，除非被 `sink`(循环入口点) 拦截

几种数据流方程

- 到达-定值

	到达定值的传递方程：
	考虑 $d:\text{u}=\text{v}+\text{w}$，那么有
	$$
	f_{d}: x \mapsto\text{gen}_{d} \cup (x-\text{kill}_{d})
		$$
	其中 $\text{gen}_{d}=\{ d \}$，$\text{kill}_{d}$ 是其他对 $u$ 的定值
	(gen-kill) 形式
	
	语句块的转移函数可以由每一个语句的转移函数复合
	
	迭代算法:
	
```python
out[entry] = emptyset

for blk in blocks - {entry}:
	out[blk] = blk.gen + (in[blk] - blk.kill)
	in[blk] = union(out[p] for p in blk.pred)
```
	
- 可用表达式

```python
out[entry] = emptyset
out[blk] = blk.e_gen + (in[blk] - blk.e_kill)
in[blk] = intersect(out[p] for p in blk.pred)
```

- 活跃变量分析
	跟到达-定值对称，gen 对应 use，kill对应def，in/out反转

```python
in[exit] = empty
for blk in blocks - {exit}:
	out[blk] = fullset
# 闭包收缩：
for blk in blocks - {exit}:
	in[blk] = blk.use + (out[blk] - blk.def)
	out[blk] = union(in[s] for s in blk.secc)
``` 

- 复写传播
`in[B]`：是复写语句s: x := y的集合，即从初始结点到块B的开始点的每条路径上都有语句s，且最后出现的s后面没有对x或y的赋值，在这个集合中只可能含有一个x在左边的复写语句（因为对x的重新赋值也会改变复写语句的影响范围）
`out[B]`：类似于in[B]，只是定义在块B的结束点
`c_gen[B]`：如果复写语句s: x := y出现在块B中，且块B中后面没有对x或y的赋值，则称s在块B中生成
`c_kill[B]`：如果x或y在B中赋值，且s不在块B中，则称s: x := y在块B中注销

```python
in[entry] = emptyset
in[blk] = intersection(out[p] for p in blk.pred)

out[blk] = blk.c_gen + (in[blk] - blk.c_kill)
```

---

### 循环不变计算

根据 ud 链找到循环不变计算（def不在循环内部）

外提循环不变计算 `s: x:=y+z`

- 含s的块是循环中所有出口结点的必经结点
- 循环中没有其它语句对x定值
- 循环中x的引用仅由s到达

### 代码外提

### 归纳变量

### 强度削弱

