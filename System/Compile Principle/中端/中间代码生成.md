## 语法树及变体

语法树的变体：DAG

构造DAG：创建节点 `new Node(op, node0, node1)` 的时候看一下节点列表，有没有三个参数均相同的，绑定到同一个 实际节点上

值编码：Node 的编号（不重）

## 三地址代码

三地址代码：`result = op arg1 arg2`

记录三地址代码可以通过 四元式表示和三元式表示，四元式表示就是记录上面的 `op, arg1, arg2, result`，而三元式表示使用指令地址表示 `result`，所以三元式表示某种意义上跟 DAG 等价，对于计算指令都是一种结构化的表示，跟指令顺序无关，只不过对于控制流表示不一样

---

## 表达式生成

> [!def] 置换 substitution
> 置换 $S$ 是一个从类型变量到类型表达式的映射，两个类型表达式 $t_{1},t_{2}$ 可以合一 (unify) 的条件是存在某个置换 $S$ 使得 $S(t_{1})=S(t_{2})$
> 如果 $t$ 是一个类型表达式， $S$ 是一个置换，那么 $S(t)$ 表示将 $t$ 中的每个变量 $\alpha$ 替换成 $S(\alpha)$ 之后的结果，$S(t)$ 被称为 $t$ 的一个实例。
> > [!example] 实例
> > $\text{list}[\text{int}]$ 是 $\text{list}[\alpha]$ 的一个实例

> [!def] 合一替换
> 如果对于类型表达式 $t_{1},t_{2}$ 有 $S(t_{1})=S(t_{2})$ ，那么 置换 $S$ 是一个合一替换
> 如果对于任意的其他合一替换 $S'$都有 $\forall t, S'(t)$ 是 $S(t)$ 的实例，那么 $S$ 是 $t_{1},t_{2}$ 的最一般合一替换。可以理解为其他的合一替换对 $t$ 的限制比 $S$ 更多

类型推导：根据已知的多态函数类型逆推要求函数的类型，推导时去掉多态类型的 $\forall$，对于每一次出现定义新变量。

例如 `if` 的类型是 $\forall\alpha.\text{boolean}\times\alpha \times\alpha\to\alpha$

```js
function length(x) = if null(x) then 0 else length(tail(x)) + 1
```

(tail 是取表尾的意思，去掉首项)

根据
- null 的类型 $\forall \alpha.\text{list}(\alpha)\to\text{boolean}$
- if 的类型 $\forall\alpha.\text{boolean}\times\alpha \times\alpha\to\alpha$
- tail 的类型 $\forall\alpha.\text{list}(\alpha)\to\text{list}(\alpha)$

可以推导出 length 的类型 $\forall\alpha.\text{list}(\alpha)\to\text{integer}$