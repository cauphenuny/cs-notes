> [!def] 属性
> 考虑语法树节点 $N$，它的文法符号为 $X$，那么 $X.a$ 表示该节点上 $X$ 的属性 $a$ 的值。

> [!def] 注释分析树
> 在语法分析树上的节点标记相应的属性值

> [!def] 综合属性
> 如果某属性在节点 $N$ 上的值由 $N$ 的字节点和 $N$ 本身的属性值确定，那么该属性称为 **综合属性**
> 只需要对语法树自底向上遍历一次就能求出综合属性的值

> [!def] 继承属性
> 继承属性：如果结点N的某个属性计算需要用到其兄弟结点或父节点的属性值，则称为继承属性

---

## 语法分析的分类

+ 自顶向下：
	+ 典型方法：递归下降、LL分析
	+ 构造简单，但是需要避免回溯，消除左递归，左因子
+ 自底向上：
	+ 从叶节点开始构造树，到树根
	+ 典型方法：算符优先、LR分析
	+ LR分析能力很强


> [!def] 左递归
> 某个非终结符 $A$ 能推导回以 $A$ 开头的串
> e.g. $A\to Aa$
> e.g. $A\to Bb,B\to Aa$

---

## 自顶向下的分析

### 预测分析法

> [!def] 预测分析法
> 预测分析法：递归下降分析的一种简单形式，非终结符号对应控制流可以由 _向前看_ 符号唯一确定 （没有回溯，对语法有强限制）

e.g. 
```
stmt
	= EXPR
	: IF ( EXPR ) stmt
	: FOR ( optexpr; optexpr; optexpr ) stmt
	: OTHER
	;

optexpr
	= <eps>
    : EXPR
    ;
```

定义 $\text{FIRST}(A)$ 是由 $A$ 生成的符号串第一个终结符构成的集合
如果两个产生式 $A\to\alpha$ 和 $A\to\beta$ 对于的 $\text{FIRST}(\alpha),\text{FIRST}(\beta)$ 交集为空，则可以根据 _lookahead_ 符号唯一确定产生式

> [!def] 左递归消除
> $A\to A \alpha\mid\beta$
> 变为
> $A\to\beta R$
> $R\to\alpha R\mid\varepsilon$

> [!example]
> `expr = expr + term`
> 变为
> ```
> expr = term rest
> rest = + term rest
>     | <eps>
>     ;
> ```

> [!def] 左公因子
> 多个产生式公用前缀，可通过构造新变元提取左公因子

嵌入语义动作：dfs，然后按访问顺序执行节点上的动作

> [!Caution] 语义动作调整
> 消除左递归后可能需要调整语义动作
> > [!example]
> > ```
> > expr -> expr + term { print('+') }
> >        |  expr - term { print('-') }
> >        |  term
> > term -> 0           { print('0') }
> >        |  1           { print('1') }
> >        | ...
> >        |  9           { print('9') }
> > ```
> > 消除左递归后：
> >  ```
> >  expr -> term rest
> >  rest -> + term { print('+') } rest
> >        |  - term { print('-') } rest
> >        | <eps>
> > term -> ...
> >  ```
> >  注意转换后语义动作放在产生式体中间，不然行为不一致


一半情况下的左递归消除：
枚举非终结符 $A_{i},A_{j}$，对 $A_{i}\to A_{j}\cdots$ 的产生式应用左递归消除


> [!def] 提取左公因子
> $A\to\alpha\beta_{1}\mid\alpha\beta_{2}\mid\dots\mid\alpha\beta_{n}\mid\gamma$
> 替换成：
> $A\to\alpha A'\mid\gamma$
> $A'\to\beta_{1}\mid\beta_{2}\mid\dots\mid\beta_{n}$

---

**验证文法生成的语言**：

验证文法生成的一定属于这个语言；验证这个语言中的串一定能被该文法生成

e.g. 
验证文法 $S \rightarrow (S)S \mid \varepsilon$ 生成的语言为具有配对括号的串  

1. 由文法推导得到的句子都是这个语言的句子  

	- 对推导步骤数 $n$ 进行归纳  
	- 基础：  
	  - $n = 1$，只能推导得到一个句子空串 $\varepsilon$，括号是配对的  
	- 归纳步骤：  
	  - 假设步数少于 $n$ 的推导得到的句子都是配对括号的串  
	  - 考虑恰有 $n$ 步的最左推导，其形式必然如下：  
	    $$
	    S \xRightarrow{lm} (S)S \xRightarrow{lm^*} (x)S \xRightarrow{lm^*} (x)y
	    $$
	    - 从 $S$ 到 $x$ 和 $y$ 的推导都少于 $n$ 步，因此 $x$ 和 $y$ 对应的符号串括号都配对  
	  - 因此 $(x)y$ 是括号配对的符号串  

2. 这个语言的句子（配对的括号串）都可以由这个文法推导得到  
	- 对符号串的长度进行归纳，注意到串的长度是偶数  
	
	- 基础：  
	  - 串的长度是 $0$，该串必然是 $\varepsilon$，是括号配对的，且可由 $S$ 推导得到  
	
	- 归纳步骤：  
	  - 假设每个长度小于 $2n$ 的配对括号串都可以从 $S$ 推导得到  
	  - 考虑长度为 $2n$ ($n \ge 1$) 的配对括号串 $\omega$  
	    - $\omega$ 必然以左括号开头，令 $(x)$ 是 $\omega$ 的最短的、括号配对的非空前缀，则 $\omega$ 可以写成 $\omega = (x)y$，其中 $x$ 和 $y$ 都是括号配对的  
	    - 因为 $x$ 和 $y$ 的长度都少于 $2n$，根据假设，$x$ 和 $y$ 都可以从 $S$ 推导得到，此时得到下面的推导：  
	      $$
	      S \Rightarrow (S)S \Rightarrow (x)S \Rightarrow (x)y
	      $$
	  - 因此 $\omega = (x)y$ 可以从 $S$ 推导得到


---

## 自顶向下分析

**二义性消除**

e.g. `if-else` 匹配问题

```
stmt
	=> IF expr THEN stmt
	|  IF expr THEN stmt ELSE stmt
	|  other
```

![[ambiguous-cfg.png]]

intuition：一个有else字句的 if 语句的 then 字句中不应该有一个没有 else 字句的 if。
没有 else 字句的 if 只能出现在末尾

消除：
```
stmt
	=> matched_stmt | open_stmt
matched_stmt
	=> IF expr THEN matched_stmt ELSE matched_stmt
    => other
open_stmt
	=> IF expr THEN 
	=> IF expr THEN matched_stmt ELSE open_stmt
```

---

First 集和 Follow 集：

$\text{FIRST}(A)$: 非终结符 $A$ 推导出的所有串的第一个字符（终结符）的集合
特别的，若存在 $A\stackrel*\implies\varepsilon$，则 $\varepsilon \in\text{FIRST}(a)$

$\text{FOLLOW}(A)$: 起始符号 $S$ 推导出的所有串中 非终结符 $A$ 对应的字串的后继终结符 集合

感受一下：
$S\stackrel*\implies\alpha A\beta\$$，则 $\text{FIRST}(\beta\$)\subseteq\text{FOLLOW}(A)$
($表示输入结束)

![[first-and-follow.png]]

---

求 First:

从产生式右侧继承 First 集合，
对于非终结符 $X\to Y_{1}Y_{2}\dots Yn$，考虑 $\text{for }i=1\dots n$，若 $Y_{1}, Y_{2},Y_{i-1}$ 的 First 集中均有 $\epsilon$，则将 $\text{FIRST}(Y_{i})$ 合并到 $\text{FIRST}(X)$

- 初始化
    - 对每个终结符 a: FIRST(a) = {a}。
    - 对每个非终结符 A: FIRST(A) = ∅（空集）。
- 对每个产生式 A → X1 X2 ... Xn 做如下规则并反复应用，直到所有 FIRST 集合不再变化（达到不动点）：
    1. 若 X1 是终结符 a，则将 a 加入 FIRST(A)。
    2. 若 X1 是非终结符 B，则将 FIRST(B) \ {ε} 加入 FIRST(A)。
    3. 若 FIRST(X1) 包含 ε，则继续看 X2，将 FIRST(X2)\\ {ε} 加入 FIRST(A)；依此类推。
    4. 若所有 Xi 的 FIRST 都包含 ε（或右边为空串），则将 ε 加入 FIRST(A)。
- 循环终止性：每步只是在集合上单调增大，且文法有限，所以必然在有限步内达到固定点。

对于串 $X_{1}X_{2}X_{3}\dots X_{n}$: 构造 $Y\to X_{1}X_{2}X_{3}\dots X_{n}$，然后用上面的方法算出 $\text{FIRST}(Y)$

求 Follow:

- 将 $\$$ 加入 $\text{FOLLOW}(S)$
- 如果存在产生式 $A\to\alpha B\beta$，则 $\text{FIRST}(\beta)$ 中除 $\varepsilon$ 以外的所有符号都在 $\text{FOLLOW}(B)$
- 如果存在一个产生式$A→αB$，或存在产生式$A→αBβ$ 且 $ε$ 在 $\text{FIRST}(β)$ 中，则 $\text{FOLLOW}(A)$ 的所有符号都在 $\text{FOLLOW}(B)$

重复，直到没有新终结符加入任意 $\text{FOLLOW}$ 集合.

---

> [!def] LL(1)
> 一个文法 $G$ 是 LL(1) 的，当且仅当 $G$ 的任意两个产生式 $A\to\alpha\mid\beta$ 满足：
> - $\text{FIRST}(\alpha) \cap\text{FIRST}(\beta)=\emptyset$ 特别地 $\varepsilon$ 不可能同时属于两个集合
> - 若 $\beta$ 可以推导成 $\varepsilon$，则 $\text{FIRST}(\alpha)\cap\text{FOLLOW}(A)$ 是空集。
> 
> _LL(1): L从左向右扫描，L产生最左推导，1每步只需要向前看一个字符_

性质：不是二义的，不含左递归，不回溯

---

构造预测分析表 $M$ ：

对于非终结符 $A$ 和 产生式 $A\to\alpha$，$\forall a \in\text{FIRST}(\alpha)$，将 $A\to\alpha$ 加入表 $M[A,a]$，若 $\varepsilon \in\text{FIRST}(\alpha)$，$\forall b\in\text{FOLLOW(A)}$，将 $A\to\alpha$ 加入 $M[A,b]$

若表中有多重项，则不是 LL(1)

---

自顶向下分析：

用栈存当前文法符号串，对栈顶元素 $A$ 和输入符号 $x$ 应用 推导式 $M[A,x]$，则 pop A，依次 push 产生式入栈 （倒序！）

---

错误恢复 - 恐慌模式：

恐慌模式 panic mode: 抛弃一些输入符号，直到输入符号属于某个同步集合

构造同步集合：
如果遇到问题，e.g. 终结符 $\alpha$ 和文本中的当前位置不匹配，则：
- (舍弃 $A$ 和错误输入) 跳过若干字符，直到出现在 $\text{FOLLOW}(A)$ 中的字符，此时弹出跟 $A$ 有关的记号，结束对 $A$ 的分析
- 将高层结构的开始记号加入底层结构的同步记号 (C语言中，若分号遗漏，可以用下一个语句的关键字当同步记号)
- (舍弃多余输入) 跳过若干字符，直到出现在 $\text{FIRST}(A)$ 中的字符，此时继续分析 $A$
- 若终结符在栈顶，可以直接弹出这个终结符，然后报告插入了此符号
- 若非终结符可以产生空串，可以apply这个产生式，减少错误恢复需要恢复的非终结符

---

错误恢复 - 短语级恢复：

将预测分析表中的空项改成 错误分析程序

错误分析程序不允许替换栈顶符号，因为需要保证不存在无限循环

---

## 自底向上分析

最左规约过程中，将所有的推导树树根从左到右连接，就能得到最右句型（最右推导过程中出现的句型）

移进-规约分析器：句柄在栈顶，每次移进一些字符后取出句柄进行规约

- 移进-规约冲突：根据输入无法判断应该移进还是规约
	移进优先，如if - then - else
  ```
  栈				输入
  $... if stmt then stmt 		else … $
  ```
	

---

> [!def] 增广文法
> 给初始项 $S$ 添加一个产生式 $S'\to S$，这样用这个产生式规约的时候就知道分析完了

> [!def] 项 item
> 一个产生式和一个表示栈顶的 $\cdot$ 符号

---

求项集 $I$ 的闭包 $\text{CLOSURE}(I)$：

1. 对项集某项 $A\to\alpha \cdot B\beta$
2. 对 $B$ 的每个产生式 $B\to\gamma$，将 $B\to \cdot\  \gamma$ 加入项集
3. 重复，直到没有新项加入

项集中的项可以分为两类：
- 内核项: $S'\to \cdot\ S$ 和点不在最左端的项
- 非内核项：除 $S'\to \cdot\ S$ 以外点在最左端的项

求闭包的时候加入的项不可能是 non-kernel，所以可以用内核项恢复一个闭包

---

求项集转移目标 $\text{GOTO}(I,X)$

$\text{GOTO}(I,X)=\text{CLOSURE}(\{ A\to\alpha X \cdot\beta \mid [A\to\alpha \cdot X\beta]\in I \})$

表示对于项集 $I$，输入 $X$ 串之后会到什么状态

---

**计算规范 LR(0) 集族**

可以理解为在初始项集族 $C=\{\text{CLOSURE}(S'\to \cdot\ S)\}$ 的基础上求闭包
闭包的每一步是对项集 $I\in C$ 对任意文法符号 $X$，加入 $\text{GOTO}(I, X)$

```python
def items(G: 增广产生式) -> set[set[Item]]:
	C = set(closure("S' -> .S"))
	while True:
		is_added = False
		for I in C: # 取每个项集
			for X in V: # 取每个文法符号
				if goto(X, V) is not None and goto(X, V) not in C:
					C.insert(goto(X, V))
					is_added = True
			
		if not is_added:
			break
```

---

**SLR(1)**: 根据 LR(0) 和 SLR(1) 构造，

考虑状态 $i$ 的语法分析动作：
- 若 $[A\to\alpha \cdot a\beta]$ 在 $I_{i}$ 中，且 $\text{GOTO}(I_{i},a)=I_{j}$，那么 $\text{ACTION}[i,a]$ 是移入 $j$ 
- 若 $[A\to\alpha \cdot\ ]$ 在 $I_{i}$ 中 ($A\neq S'$)，那么对于 $\text{FOLLOW}(A)$ 中的所有 $a$，$\text{ACTION}[i,a]$ 是 规约 $A\to\alpha$
- 若 $S'\to S\cdot\,$ 在 $I_{i}$ 中，那么 $\text{ACTION}[i,\$]$ 是接受

产生冲突了就说明这个文法不是 **SLR(1)** 的

---

符号可以从状态中提取（自动机是根据 GOTO(I,X) 构造的，所以一个状态只能对应一个文法符号（note: 一个符号可以对应多个状态）），所以栈可以只保存项集状态

---

**LR(1) 项集**

加入 Look Ahead 符号，
形如 $A\to\alpha \cdot\beta, \ a$，若 $\beta\neq\varepsilon$，向前符号无用，但形如 $A\to\alpha\ \cdot,\ a$ 的情况下，只有下一个输入符号是 $a$ 的时候才会按 $A\to\alpha$ 规约，可以减少一些 SLR 冲突的情况

---

构造 LR(1) 项集：

求项集闭包：
- 重复对每一项 $[A\to\alpha \cdot B\beta,\,a]$：
- 对于每一个 $G'$ 中的产生式  $B\to\gamma$
- 考虑 $\text{FIRST}(\beta a)$ 中的每个终结符 $b$，将 $[B\to \cdot \ \gamma,\,b]$ 加入集合

求闭包时加入的 Look Ahead 信息会随着状态机构建过程，暴露到栈顶（从形如 $A\to\alpha \cdot B\beta,\,a$ 到 $A\to\gamma \cdot\ ,\ a$），从而参与构建 ACTION

---

**LALR 文法**

合并 Canonical LR(1) 的项集，如果 kernel 完全相同，则合并，kernel 是项的产生式部分。

LALR 合并时不会产生新的规约/移入冲突，因为若产生冲突 $[A\to\alpha \cdot\ ,\,a] \Leftrightarrow [B\to\beta \cdot a\gamma,\,b]$ ，因为被合并的项集 kernel 是完全相同的，必存在某一个项集包含 $[A\to\alpha \cdot\ ,\, a]$ 和 $[B\to\beta \cdot a\gamma,\ c]$，$c$ 可以是任意一个终结符，此时这个项集本身就有移入/规约冲突，说明不是 LR(1) 文法。

合并时可能有规约/规约冲突

因为移进只由核心控制，所以尽管 LALR 可能报错相比 LR 会有一些延迟（多规约了几项），但不会移入新的终结符

---

