## 有符号数/无符号数

使用 $,$ 或 $.$ 分割符号位和数值部分

原码/反码/补码不再赘述

移码：补码很难判断真值大小，加 $2^n$ 

IEEE 754 浮点数：$S(1)+E(8)+M(23)$ 尾数为 **原码** 规格化数，最高位隐含为 1.，阶码为移码

偏移量：短/长/临时实数：$7F\text{H},3FF\text{H},3FFF\text{H}$

机器零：尾数为0 / 阶码为最小值

## 定点运算

### 移位

算数移位：补算数意义上的 $0$，具体在不同的码表示中可能是 1

溢出和误差：

左移可能产生溢出错误（写结果时保持符号位不变），右移可能导致精度损失
- 正数：原码、补码、反码中，均是 1 才有意义
  左移丢 1 产生溢出错误，右移丢 1 导致精度损失
- 负数：原码 1 有意义，反码 0 有意义，补码高位 0 有意义，最低的 1 有意义
  原码：总是丢 1 错
  反码：总是 丢 0 错
  补码：左移丢 0 错，右移丢 1 错

### 加法

加法

> [!theorem] 一位符号位加法判断溢出
> 符号位进位 $x_{0}$ 和最高有效位进位 $x_{1}$ 异或 $x_{0}\otimes x_{1}$ 值为 1 则溢出

> [!proof]
> 如果两加数符号不同，那么最高有效位进位一定和符号位进位相同（符号位本身和为 $1$），不会溢出
> 如果加数符号相同，若最高有效位进位和符号位不同，代表数值绝对值超过 $2^n$ 溢出。

> [!theorem] 两位符号为判断溢出
> 比较计算之后的两位符号位是否相同，若不同则溢出

> [!proof]
> 类似

### 乘法

#### 原码乘法

原码一位乘：不断作加法+移位，符号位单独考虑

![[原码一位乘.png]]

原码两位乘：考虑 $y_{n-1}y_{n}$ 分别加 0,1,2,3 倍的被乘数，3 倍相当于减 1 倍再加 4 倍(右移两位之后加一倍即可，设标志位 $C_{j}$)

注意加了两倍被乘数，可能值超过 $2$，使用三位符号位

为了消耗最后一个 $C_{j}$，乘数前补两个 0，（奇数补1个，最后一步移1位）

![[原码两位乘Cj.png]]

![[原码两位乘.png]]

#### 补码乘法

被乘数为正的情况，和原码一样，都是 $[z_{0}]_\text{补}=0,[z_{i+1}]_\text{补}=2^{-1}(y_{n-i}[x]_\text{补}+[z_{i}]_\text{补})$

被乘数为负的情况，考虑 $[y]_\text{补}=1.y_{1}y_{2}\dots y_{n}=2+y \pmod 2$
$\implies y=[y]_\text{补}-2=0.y_{1}y_{2}y_{3}\dots y_{n}-1$

$x\cdot y=x(0.y_{1}y_{2}\dots y_{n}-1)=x(0.y_{1}y_{2}\dots y_{n})-x$

$[x\cdot y]_\text{补}=[x(0.y_{1}y_{2}\dots y_{n})]_\text{补}+[-x]_\text{补}$

##### 校正法

可以先算前一项（把y直接去掉符号为当正数）然后减去 $x$ ，称为校正法。

运算时可能出现绝对值大于 1 的情况，使用两位符号位。
##### Booth 算法

$[x\cdot y]_\text{补}=[x]_\text{补}(0.y_{1}y_{2}y_{3}\dots y_{n})-[x]_\text{补}\cdot y_{0}$

$$
\begin{aligned}
x\cdot y_\text{补}&=[x]_\text{补}(y_{1}2^{-1}+y_{2}2^{-2}+\cdots+y_{n}2^{-n})-[x]_\text{补}\cdot y_{0}\\
&=[x]_\text{补}[-y_{0}+(y_{1}-y_{1}2^{-1})+\cdots+(y_{n}2^{-(n-1)}-y_{n}2^{-n})]\\
&=[x]_\text{补}((y_{1}-y_{0})+(y_{2}-y_{1})2^{-1}+\cdots+(y_{n+1}-y_{n})2^{-n})
\end{aligned}
$$

其中 $y_{n+1}=0$

类似之前的递推公式，只不过把 $y_{i}$ 换成 $y_{i+1}-y_{i}$，最后一步由 $y_{1}-y_{0}$ 决定是加还是减还是加0，但不移位


| $y_{i}y_{i+1}$ | $y_{i+1}-y_{i}$ | op                      |
| -------------- | --------------- | ----------------------- |
| 00             | 0               | $\gg {1}$               |
| 01             | 1               | $+[x]_\text{补};\gg {1}$ |
| 10             | -1              | $+[-x]_\text{补};\gg 1$  |
| 11             | 0               | $\gg 1$             |
![[booth.jpeg]]

通过合并相邻两次的 $y_{i+1}y_{i}$ 还可以做到补码两位乘，例如 $y_{n-1}y_{n}y_{n+1}=011$，第一步右移，第二步$+[x]_\text{补}$，总操作为 $2^{-1}(2^{-1}[z_{i}]_\text{补}+[x_{}]_\text{补})=2^{-2}([z_{i}]_\text{补}+2[x]_\text{补})$

### 除法

小数定点除法对于被除数和除数的要求：$0<\lvert 被除数 \rvert\leq \lvert 除数 \rvert$

#### 原码除法

##### 恢复余数法与加减交替法

恢复余数法：
1. 作减法，如果为正则商1，反之商0，将被除数加回去。
2. 余数左移一位

考虑余数的范围，使用归纳法证明它一定在 $\lvert y \rvert$ 范围内。

初始条件：$\lvert 被除数 \rvert\leq \lvert 除数(y) \rvert$

- $R>0\implies \lvert 2R-y \rvert\leq \lvert y \rvert$
- $R\leq 0\implies \lvert 2R+y \rvert\leq \lvert y \rvert$
所以余数的范围一定在 $[-Y,Y)$ 范围内，可以只用一位符号位.

加减交替法：

- $R_{i}>0\implies$ 商 1，做 $2R_{i}-y^*$ 运算
- $R_{i}<0\implies$ 商 0，做 $2R_{i}+y^*$ 运算

![[加减交替法.png]]


#### 补码除法

如果规定商值的最后一位是1，那么除了这一位以外其余的商值对于正商和负商而言上商规则是刚好不同的。

![[div.png]]
![[div2.png]]
由于被除数绝对值小于除数的限制，在第一步上商时能自动确定符号
- $[x]_\text{补},[y]_\text{补}$ 同号，第一步不够减 $[R]_\text{补},[y]_\text{补}$ 异号，上商 0
- $[x]_\text{补},[y]_\text{补}$ 异号，第一步不够减 $[R]_\text{补},[y]_\text{补}$ 同号，上商 1

新余数的获取方法：
- $[R_{i}]_\text{补},[y]_\text{补}$ 同号，商 1 ，新余数 $[R_{i+1}]_\text{补}=2[R_{i}]_\text{补}+[-y]_{\text{补}}$
- $[R_{i}]_\text{补},[y]_\text{补}$ 异号，商 0 ，新余数 $[R_{i+1}]_\text{补}=2[R_{i}]_\text{补}+[y]_{\text{补}}$

简记：同减异加，使得 $R$ 逐渐接近0

### 快速进位

进位 $C_{i}=A_{i}B_{i}+(A_{i}+B_{i})C_{i-1}$

本地进位 $d_{i}:=A_{i}B_{i}$，传递进位 $t_{i}=A_{i}+B_{i}$

串行进位链：$C_{i}=d_{i}+t_{i}C_{i-1}$

并行进位链：
![[image 1.png|443x123]]

单重分组跳跃进位链

![[reg-save.png]]

双重分组跳跃进位链

![[image-3.png]]

![[image 1.png]]