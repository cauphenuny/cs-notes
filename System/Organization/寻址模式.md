EA: effective address，有效地址
A：形式地址
- 立即寻址 `#A`: 形式地址就是操作数
- 直接寻址  `A`:  形式地址就是有效地址
- 隐含寻址：操作数地址隐含在操作码中（$e$.$g$. 8086 `MUL`地址：`AX/AL` （16位/8位）
- 间接寻址 `(A)`或`@A`: 有效地址由形式地址间接提供：先通过地址 A 访问主存得到有效地址，然后再寻址一次。也可以多次间址，留一位作标志位
  ![[Pasted image 20250502212038.png]]
- 寄存器寻址`EA=`$R_A$： 有效地址：寄存器编号 $A$
- 寄存器间接寻址 `(R_A)`
- 基址寻址：`EA=BR+A`，其中BR是基址寄存器，由系统指定，也可以用通用寄存器作为基址寄存器。执行过程中寄存器内容不变，A内容可变
- 变址寻址：`EA=(IX)+A` IX 是变址寄存器，内容可变，形式地址 $A$ 不变，便于处理数组问题
> [!example] 设数组首地址为 $D$ ，求 $N$ 个数平均值
> 直接寻址：
> ```
> LDA D
> ADD D+1
> ADD D+2
> ...
> ADD D+(N-1)
> DIV #N
> STA ANS
> ```
> 共 $N+1$ 条指令
> 
> 变址寻址：
> ```
> LDA #0
> LDX #0        ; $X$ 为变址寄存器
> M:
> ADD X, D      ; $D$ 为形式地址
> INX           ; (X)+1->X
> CPX #N
> BNE M
> DIV #N
> STA ANS
> ```
- 相对寻址 `*A`：相对 PC 找操作数位置，用于跳转指令或者生成位置无关代码（可以加载到内存任意位置，变量相对指令的偏移量不变）
- 堆栈寻址

> [!question]
> 基址和变址的区别

基址寻址和变址寻址是两种常见的寻址方式，它们在计算内存有效地址时都涉及寄存器与偏移量的组合，但设计目的和应用场景不同。以下是它们的核心区别：

---

### **1. 核心目的**
- **基址寻址（Base Addressing）**  
  主要用于**逻辑地址到物理地址的转换**，例如程序重定位或内存分段管理。基址寄存器的值通常由操作系统设定，程序无需关心具体物理地址，只需通过基址+偏移访问数据。
  
- **变址寻址（Indexed Addressing）**  
  主要用于**遍历数组或结构化数据**。变址寄存器的值由程序控制（如循环计数器），便于动态计算地址，适合处理连续数据的灵活访问。

---

### **2. 寄存器与偏移量的角色**
| **特性**       | **基址寻址**                          | **变址寻址**                          |
|----------------|--------------------------------------|--------------------------------------|
| **寄存器内容** | 基址寄存器（Base Register）保存**基地址**（起始地址）。 | 变址寄存器（Index Register）保存**偏移量**（索引值）。 |
| **偏移量来源** | 偏移量由指令直接给出（固定值）。          | 基地址由指令直接给出（固定值）。          |
| **有效地址计算** | `有效地址 = 基址寄存器值 + 指令中的偏移量` | `有效地址 = 指令中的基地址 + 变址寄存器值` |

---

### **3. 应用场景**
- **基址寻址**  
  - 多道程序设计中，操作系统通过修改基址寄存器实现进程地址空间隔离。  
  - 动态链接库加载时，基址寄存器指向库的起始地址。  
  - 示例：`MOV AX, [BX + 0x1000]`（BX为基址寄存器，0x1000为偏移）。

- **变址寻址**  
  - 循环遍历数组元素，如`for (i=0; i<N; i++) arr[i]`。  
  - 访问结构体中的字段（如`struct.field`）。  
  - 示例：`MOV AX, [SI + 2000H]`（SI为变址寄存器，2000H为基地址）。

---

### **4. 寄存器管理**
- **基址寄存器**  
  通常由操作系统或硬件管理，程序一般无法直接修改（如x86的段寄存器）。  
- **变址寄存器**  
  由程序主动控制（如x86的SI/DI），常用于循环中递增或递减索引值。

---

### **5. 其他特性**
- **灵活性**  
  变址寻址更适合处理动态偏移（如循环中的索引），而基址寻址更适合静态地址分配。  
- **典型架构**  
  - x86：`BX`/`BP`常用于基址寻址，`SI`/`DI`用于变址寻址。  
  - ARM：基址寄存器（如`R1`）配合立即数偏移，或通过`LDR R0, [R1, R2]`实现变址（R2为索引）。

---

### **总结**
- **基址寻址** = **静态基地址** + **固定偏移**（适合内存分段）。  
- **变址寻址** = **固定基地址** + **动态偏移**（适合数组遍历）。  

两者结合使用（如`[BX + SI + 10]`）可进一步扩展寻址能力，常见于复杂数据结构的访问。

> [!question]
> 段寻址和页面寻址的区别

段寻址（Segmentation）和页面寻址（Paging）是两种不同的内存管理技术，主要用于实现虚拟内存和物理内存的映射。它们的核心区别在于内存划分方式、地址转换逻辑以及应用场景。以下是详细对比：

---

### **1. 内存划分方式**
| **特性**       | **段寻址（Segmentation）**                     | **页面寻址（Paging）**                      |
|----------------|-----------------------------------------------|--------------------------------------------|
| **内存单元**   | 内存被划分为**逻辑段**（如代码段、数据段、堆栈段等），每段的大小可变。 | 内存被划分为**固定大小的页**（如4KB、2MB等），物理和虚拟页大小一致。 |
| **划分依据**   | 按程序逻辑（如函数、数组、堆栈）划分。           | 按物理存储的方便性划分，与程序逻辑无关。       |
| **碎片问题**   | 易产生**外部碎片**（段间无法利用的小块内存）。     | 产生**内部碎片**（页内未使用的内存）。         |

---

### **2. 地址转换机制**
| **特性**       | **段寻址**                                    | **页面寻址**                                |
|----------------|-----------------------------------------------|--------------------------------------------|
| **地址组成**   | 逻辑地址 = **段选择符（段号） + 段内偏移量**。  | 逻辑地址 = **虚拟页号 + 页内偏移量**。       |
| **映射表**     | 段表（Segment Table）：存储段基址和段界限。     | 页表（Page Table）：存储虚拟页到物理页的映射。 |
| **转换过程**   | 1. 通过段选择符查找段表，获取段基址和段界限；<br>2. 检查偏移量是否越界；<br>3. **物理地址 = 段基址 + 偏移量**。 | 1. 通过虚拟页号查找页表，获取物理页号；<br>2. **物理地址 = 物理页号 × 页大小 + 页内偏移量**。 |
| **保护机制**   | 通过段界限和访问权限（读/写/执行）实现保护。      | 通过页表项的权限位（读/写/执行）实现保护。     |

---

### **3. 设计目标与优缺点**
| **特性**       | **段寻址**                                    | **页面寻址**                                |
|----------------|-----------------------------------------------|--------------------------------------------|
| **核心目标**   | **按逻辑隔离程序组件**，方便程序员理解和管理。   | **高效利用物理内存**，支持虚拟内存和按需加载。 |
| **优点**       | - 逻辑直观，符合程序结构（如代码、数据分离）；<br>- 支持动态扩展（如堆栈段）。 | - 消除外部碎片；<br>- 简化内存分配；<br>- 支持虚拟内存（如交换到磁盘）。 |
| **缺点**       | - 外部碎片问题严重；<br>- 内存分配效率低；<br>- 难以支持大规模虚拟内存。 | - 内部碎片可能浪费内存；<br>- 页表可能占用大量内存（需多级页表或反向页表）。 |

---

### **4. 实际应用**
| **特性**       | **段寻址**                                    | **页面寻址**                                |
|----------------|-----------------------------------------------|--------------------------------------------|
| **典型场景**   | - 早期x86架构（如8086的代码段、数据段）；<br>- 嵌入式系统中对内存隔离要求简单的场景。 | - 现代操作系统（如Linux、Windows）的主流内存管理方式；<br>- 支持虚拟内存的系统。 |
| **硬件支持**   | 需要段寄存器（如x86的CS、DS）和段描述符表。     | 需要页表基址寄存器（如x86的CR3）和TLB（快表）。 |
| **混合使用**   | 某些架构（如x86-32）同时支持段和页，形成**段页式内存管理**：<br>逻辑地址 → 段机制 → 线性地址 → 页机制 → 物理地址。 | 纯页式系统（如x86-64长模式）通常禁用段机制，仅使用页表。 |

---

### **5. 总结对比表**
| **维度**       | **段寻址**                                    | **页面寻址**                                |
|----------------|-----------------------------------------------|--------------------------------------------|
| **内存划分**   | 可变大小逻辑段                                 | 固定大小物理页                              |
| **碎片问题**   | 外部碎片                                       | 内部碎片                                    |
| **地址转换**   | 段基址 + 偏移量                                | 物理页号 + 页内偏移                         |
| **保护机制**   | 段界限和权限位                                 | 页表权限位                                  |
| **适用场景**   | 逻辑隔离需求高、嵌入式系统                     | 现代通用操作系统、虚拟内存系统              |
| **硬件复杂度** | 较高（需段寄存器和段表）                       | 较低（依赖页表和TLB）                      |

---

### **关键区别总结**
1. **逻辑 vs 物理**  
   - 段寻址按程序逻辑划分内存，页寻址按物理存储需求划分。
2. **灵活性**  
   - 段寻址支持动态扩展（如堆栈增长），页寻址通过固定页简化管理。
3. **碎片与效率**  
   - 段寻址的外部碎片导致内存利用率低，页寻址的内部碎片可控且易优化。
4. **现代应用**  
   - 页寻址是主流（支持虚拟内存），段寻址多用于历史架构或特定场景。

---

### **补充说明**
- **段页式结合**：x86等架构通过**段页式内存管理**融合两者优势，先用段机制隔离程序组件，再用页机制分配物理内存。
- **虚拟内存**：页寻址天然支持按需分页和页面置换（如LRU算法），而段寻址难以实现高效的磁盘交换。

> [!question]
> 段寄存器是如何工作的？

在x86架构中，**段寄存器**（Segment Registers）是用于内存分段管理的关键组件，其内容在不同运行模式（如实模式、保护模式）下有不同的含义。以下是段寄存器存储内容的详细说明：

---

### **1. 段寄存器的基本作用**
段寄存器的作用是配合偏移地址（Offset）生成内存的**逻辑地址**，再通过分段机制转换为**物理地址**（实模式）或**线性地址**（保护模式，需进一步分页转换）。  
常见的段寄存器包括：
- **CS**（Code Segment）：代码段寄存器，指向当前执行的代码段。
- **DS**（Data Segment）：数据段寄存器，指向默认的数据段。
- **SS**（Stack Segment）：堆栈段寄存器，指向堆栈段。
- **ES/FS/GS**（Extra Segments）：附加数据段寄存器，用于扩展数据访问。

---

### **2. 不同模式下的段寄存器内容**
#### **(1) 实模式（Real Mode）**
- **存储内容**  
  段寄存器直接存储**段基址的高16位**（即段基址 = 段寄存器值 × 16）。  
  例如：若 `CS=0x1234`，则代码段的基址为 `0x12340`（`0x1234 << 4`）。

- **地址计算**  
  物理地址 = **段寄存器值 × 16 + 偏移地址**  
  示例：  
  ```asm
  MOV AX, [DS:0x5678]  ; 物理地址 = DS × 16 + 0x5678
  ```

- **特点**  
  - 段寄存器直接参与物理地址计算。
  - 段大小为固定64KB（因偏移地址为16位）。

---

#### **(2) 保护模式（Protected Mode）**
在保护模式下，段寄存器存储的是**段选择符**（Segment Selector），而非直接基址。  
段选择符通过索引全局描述符表（GDT）或局部描述符表（LDT）获取段描述符（Segment Descriptor）。

- **段选择符结构**  
  ```
  | 15..3 | 2 | 1..0 |
    索引   表指示符  特权级
  ```
  - **索引（Index）**：13位，指向GDT/LDT中的描述符条目。
  - **表指示符（TI）**：0=GDT，1=LDT。
  - **特权级（RPL）**：请求特权级（0=内核，3=用户）。

- **段描述符（Segment Descriptor）**  
  存储在GDT/LDT中的8字节结构，包含以下关键信息：
  - **段基址（Base Address）**：32/64位，段的起始物理地址。
  - **段界限（Limit）**：20位，段的大小（单位由粒度位决定）。
  - **访问权限**：读/写/执行权限、特权级等。
  - **粒度（G）**：0=段界限单位为1字节，1=单位为4KB。

- **地址转换流程**  
  1. CPU从段寄存器（如`CS`）读取段选择符。
  2. 根据段选择符的`TI`位选择GDT或LDT。
  3. 用`索引`找到对应的段描述符。
  4. 检查段界限和权限是否合法。
  5. 物理地址（或线性地址）= **段基址 + 偏移地址**。

---

### **3. 现代x86-64架构中的段寄存器**
在x86-64长模式（Long Mode）下，段寄存器的功能被大幅简化：
- **段基址强制为0**（除`FS`和`GS`外），逻辑地址直接等于偏移地址。
- **段界限被忽略**，内存保护完全依赖分页机制。
- **段寄存器用途变化**：
  - `CS`/`SS`：仅用于设置当前特权级（CPL）。
  - `FS`/`GS`：保留特殊用途（如Windows/Linux中用于线程本地存储）。

---

### **4. 段寄存器的具体内容示例**
#### **实模式示例**
```asm
MOV AX, 0x1234
MOV DS, AX       ; DS=0x1234，段基址=0x12340
MOV BX, 0x5678   ; 偏移地址=0x5678
MOV AL, [BX]     ; 物理地址=0x12340 + 0x5678 = 0x179B8
```

#### **保护模式示例**
```asm
; 假设GDT中定义了一个描述符：
; 索引=1，基址=0x100000，界限=0xFFFFF，粒度=4KB（段大小=4GB）
MOV AX, 0x0008  ; 选择符：索引=1，TI=0（GDT），RPL=0
MOV DS, AX       ; 加载段选择符到DS
MOV EAX, [0x1234]; 线性地址=0x100000 + 0x1234 = 0x101234
```

---

### **5. 段寄存器的核心总结**
| **模式**       | **段寄存器内容**                | **作用**                                 |
|----------------|--------------------------------|-----------------------------------------|
| **实模式**     | 段基址的高16位（×16后为基址）    | 直接参与物理地址计算                      |
| **保护模式**   | 段选择符（索引GDT/LDT）          | 通过段描述符获取基址和权限，支持内存保护    |
| **x86-64长模式**| 大部分段基址强制为0              | 仅用于特权级控制或特殊用途（如FS/GS）      |

---

### **关键点**
1. **实模式**：段寄存器直接存储基址，地址计算简单但无保护。
2. **保护模式**：段寄存器存储选择符，通过描述符实现灵活的内存管理和保护。
3. **x86-64**：段机制被弱化，分页成为内存管理核心。

通过段寄存器，x86架构实现了从简单实模式到复杂保护模式的演进，平衡了兼容性与安全性需求。