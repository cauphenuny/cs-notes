## x86架构寄存器

## 1. 通用寄存器

### 1.1 i386 32位模式
- **EAX**：累加器，主算术运算寄存器  
- **EBX**：基址寄存器，内存访问基地址存储  
- **ECX**：计数器，循环/字符串操作计数  
- **EDX**：数据寄存器，I/O操作辅助  
- **ESI**：源索引，数据操作源指针  
- **EDI**：目标索引，数据操作目标指针  
- **ESP**：堆栈指针，管理函数调用栈，包括ESP指向的地址本身
- **EBP**：基址指针，函数栈帧基准地址  

### 1.2 x86-64 64位扩展
- **RAX/RBX/RCX/RDX**：  
  ▸ 64位扩展，保留原有功能  
  ▸ 低32位仍可通过EAX/EBX/ECX/EDX访问  
- **RSP/RBP/RSI/RDI**：  
  ▸ 64位扩展，功能与32位模式一致  
  ▸ 低32位为ESP/EBP/ESI/EDI  
- **新增R8-R15**：  
  ▸ 8个64位通用寄存器  
  ▸ 兼容32位模式（R8D-R15D）、16位（R8W-R15W）、8位（R8B-R15B）  
  ▸ 增强复杂计算与参数传递能力  

---

## 2. 段寄存器（保护模式）
- **CS**：代码段，指向当前执行指令段  
- **DS**：数据段，默认数据访问段  
- **SS**：堆栈段，堆栈操作段基址  
- **ES/FS/GS**：附加数据段  
  ▸ **x86-64特性**：  
  - 大多数场景取消显式段寄存器依赖  
  - FS/GS保留用于线程局部存储(TLS)和操作系统特殊用途  

---

## 3. 标志寄存器
- **EFLAGS (32位)** / **RFLAGS (64位)**：  
  ▸ **CF**：进位标志（无符号运算溢出）  
  ▸ **ZF**：零结果标志（运算结果为0时置位）  
  ▸ **SF**：符号标志（运算结果最高有效位）  
  ▸ **OF**：溢出标志（有符号运算溢出）  

---

## 4. 指令指针
- **EIP (32位)** / **RIP (64位)**：  
  ▸ 存储下一条待执行指令地址  
  ▸ x86-64模式下支持64位线性地址空间  

![[reg.png]]

调用者保存：被调用者随便改，调用者已经把数据存起来了（如果要用的话）
被调用者保存：函数中push之后就可以用来存临时变量，ret前pop
## 栈的特性(x86-linux-32)：
- 自顶向下生长
- 栈底地址是`0xbffffxxx`
- 栈单元：4 byte
![[Pasted image 20250417230320.png]]
![[Pasted image 20250417230354.png]]
## 过程调用指令

- `CALL dest`: 下一条指令地址压栈，跳转到dest
- `RET`:返回（eip <= pop()）
- `RET n`：先退栈 $n$ 字节，然后返回
- `PUSH/POP`：略
- `LEAVE`：释放栈帧

| Instruction | Effective op                      |
| ----------- | --------------------------------- |
| `call addr` | `pushl %eip; jmp addr`            |
| `ret`       | `pop %eip`                        |
| `pushl src` | `subl $4, %esp; movl src, (%esp)` |
| `popl dest` | `movl (%esp) dest; addl $4, %esp` |
| `leave`     | `movl %ebp, %esp; popl %ebp`      |
![[reg-save.png]]