(x86-64)
## 传送指令

$b$: byte
$w$: word
$l$: long (2 words)
$q$: quad (4 words)

第一类：`movb/movw/movl/movq/movabsq`

注意：
- `movl` 会自动把数从2字节 **零**扩展 到4字节。
- `movq` 不能使用超过 32 位的立即数，如果要用，换成 `movabsq`指令。


第二类：`movzbw/movzwl/movslq` 等

`z/s` : 零扩展或符号扩展
剩下两位：长度标识符
没有 `movzlq`，因为行为跟 `movl` 一样

> [!warning] esp不能做变址索引
> x86/IA-32，基址加变址（索引）寻址：
> 基址寄存器：eax, ebx, ecx, edx, esi, edi, ebp, **esp**
> 变址（索引）寄存器：eax, ebx, ecx, edx, esi, edi, ebp
> $\implies$ `movl 4(,%esp,2), %eax` esp 不能作 index




## 跳转指令

直接跳转：`jmp label`

间接跳转: `jmp *%rax` 用 rax 值作为跳转目标，或者 `jmp *(%rax)`，用 rax 值作为内存读取地址，读取的值作为跳转目标

PC相对寻址时，相对的是下一条指令的PC。

CSAPP中，如果跳转指令下一条指令是`ret`，会在`ret`前加上 `rep;` 指令，使得 ret 不作为跳转指令的目标，可以去掉 `rep` 对理解无影响（来自AMD对编译器的建议）

跳转表：用于实现switch语句

```asm
.section .rodata # readonly data
.align 8
.Lswitch_label:
	.quad .L1
	.quad .L2
	.quad .Ldefault
	.quad .L2
	.quad .L3

.section .text

switch:
	cmp $4, %rsi
	ja .Lret
	jmp *.Lswitch_label(,%rsi,8)
.L1:
	...
.L2:
	...
.L3:
	...
.Ldefault:
	...
.Lret:
	ret
```

## .repr 汇编指导

重复 count 次，直到 .endr
```
.rept 3
	.long 0
.endr

# equals to

.long 0
.long 0
.long 0
```

