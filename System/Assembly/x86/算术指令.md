EFLAGS状态标志位：
- CF - Carry: 无符号数运算溢出
- OF - Overflow：有符号数运算溢出
- SF - Sign：结果为负数
- ZF - Zero：结果为0
- AF - Auxiliary Carry：辅助进位：Bit 3 到 Bit 4 的进位

对应`set`: `set(n)e/set(n)s` (不)相等/负数
`setg/setge/setl/setle`: 有符号比较, greater/less
`seta/setae/setb/setbe`: 无符号比较, above/below

less 的跳转条件：`SF ^ OF`: `SF==1,OF==0` 的情况对应正常 $A-B<0$，而 `SF==0,OF==1` 的情况对应一个负数减去一个较大正数，使得结果为正，且overflow。

`imulq` 可以接受一个/两个操作数，接受两个时正常算64位乘积，接受一个时：目的寄存器隐含为 `rdx:rax`，存储128位结果

`imulq S`: `rdx:rax = S * rax`

> [!question]
> 如何用标志位决定 g/ge/l/le？

- SF（Sign Flag）

标志结果是否为负数：
	•	SF = 1 → 结果为负
	•	SF = 0 → 结果为正或零

- OF（Overflow Flag）

表示算术运算中是否发生了有符号数溢出
	•	溢出 → OF = 1
	•	没溢出 → OF = 0

---

🎯 有符号比较的核心：

SF ≠ OF → 结果为负数（小于）
SF == OF → 结果为非负（大于等于）

这可以理解为：SF 反映了结果的“符号”，而 OF 表明这个符号是否可信（是否因溢出而错误）

---

🧠 为什么这么组合？

🔹 例子：jl（Jump if Less）
	•	cmp a, b 会做 a - b，并设置 SF / OF 等标志。
	•	若 a < b（带符号），则：
	•	a - b < 0 → SF = 1
	•	若结果没有溢出 → OF = 0
	•	或者结果溢出导致错误的正值 → SF = 0, OF = 1
→ 只要 SF ≠ OF，就说明比较结果是负的（即 a < b）

---

📋 总结图表

| 有符号条件 | 含义         | 跳转条件                                       |
| ----- | ---------- | ------------------------------------------ |
| l     | <(signed)  | $\text{SF}\neq\text{OF}$                   |
| ge    | >=(signed) | $\text{SF}=\text{OF}$                      |
| g     | >(signed)  | $\overline{\text{ZF}},\text{SF}=\text{OF}$ |
| le    | <=(signed) | $\text{ZF}\mid\text{SF}\ne\text{OF}$       |

---

无符号比较用的是 CF（进位标志）和 ZF：

| 无符号条件 | 条件                                          |
| ----- | ------------------------------------------- |
| a     | $\overline{\text{CF}},\overline{\text{ZF}}$ |
| b     | $\text{CF}$                                 |
| ae    | $\overline{\text{CF}}$                      |
| be    | $\text{CF}\mid\text{ZF}$                    |

---

对于 `test` 指令：
- ZF: 结果为零则设置
- SF: 根据结果符号设置
- PF: 最低字节有偶数个1则设置
- CF/OF: 0
- AF: 未定义

对比上面的表格，可以发现 `test + <inst>l/ge/g/le` 组合相当于与0进行比较

