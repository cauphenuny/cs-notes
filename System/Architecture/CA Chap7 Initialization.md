> [!info] 关于 BAR 的 mask
> 你问得非常对，**BAR 的 mask 不是简单地“写 0xFFFFFFFF 读回来”这么粗暴的东西**，很多教程把这件事讲得太随意，导致误解。
> 
> 下面我把整个 BAR mask 的真实含义彻底讲清楚，并且解释你提出的三个关键点：
> 
> 1. **什么是 mask？**
>     
> 2. **为什么写全 1 就能读到 mask？**
>     
> 3. **BAR 的低几位为什么不是 size 位？为什么不需要“特殊处理”？**
>     
> 
> ---
> 
> ### 🚩 1. 什么是 BAR mask？
> 
> 对一个 BAR，设备需要告诉系统：
> 
> - 我需要多少连续的地址空间
>     
> - 这些空间的最小对齐是多少
>     
> 
> 但 BAR 寄存器本身只有 **一个地址寄存器**，无法直接告诉系统“大小是多少”。
> 
> PCI 规范的解决办法：
> 
> > **用 BAR 寄存器的低 N 位固定为 0**，这样 BAR 只能填对齐后的地址，设备就可以用这些固定为 0 的 bit 来表示自己的大小。
> 
> 例如：
> 
> - 大小 = 4 KB → BAR 的低 12 位不能被 CPU 写
>     
> - 大小 = 256 MB → BAR 低 28 位都是只读 0
>     
> 
> 因此 mask 的含义是：
> 
> > **BAR 哪些位是硬件固定为 0，这些位反过来就表示 BAR 的大小（对齐单位）。**
> 
> 这就是 mask 的来源。
> 
> ---
> 
> ### 🚩 2. 为什么“写 0xFFFFFFFF，读回来”就能得到 mask？
> 
> 这条规则是 **PCI 规范硬性规定的机制**：
> 
> ##### 操作流程
> 
> 1. 软件向 BAR 写 `0xFFFFFFFF`
>     
> 2. 硬件会：
>     
>     - 屏蔽掉只读固定为 0 的位（表示大小）
>         
>     - 保留可写位置 1
>         
> 3. 软件读回来，得到的就是 mask
>     
> 
> 例如设备 BAR 大小为 4KB：
> 
> ```
> 写入：  0xFFFFFFFF
> 读出：  0xFFFFF000  ← 低 12 位被硬件强制置 0
> ```
> 
> 例如设备 BAR 大小为 64KB：
> 
> ```
> 写入：  0xFFFFFFFF
> 读出：  0xFFFF0000  ← 低 16 位被硬件强制置 0
> ```
> 
> 写 1 会被硬件抹掉 → 哪些位被抹掉就告诉了你“这些位不能用作地址 → 用来表示大小”。
> 
> **这不是 CPU 的行为，是 PCI 设备内的硬件逻辑要求。**
> 
> ---
> 
> ### 🚩 3. 你问：BAR 的低位不是包含类型标志吗？为什么“写全 1”还能得到正确 mask？
> 
> 是的！你非常清楚：
> 
> ##### BAR 的低 bits **不是用来表示大小的**：
> 
> ```
> bit0   = 1 表示 I/O BAR，0 表示 memory BAR
> bit1-2 = MMIO BAR 的类型（32bit / 64bit / reserved）
> bit3..N-1 = 对齐大小（硬件固定为 0）
> ```
> 
> 所以“低 4 位写不了”这件事是对的。
> 
> 但问题是：**PCI 规范要求设备在 mask 测试时返回 size 信息，忽略 BAR 属性位**。
> 
> 也就是说：
> 
> ▶ 写 mask 时的读取结果中：
> 
> - 类型位（bit 0–3）也会被强制置为 0
>     
> - 只有 size bits 起作用
>     
> 
> 比如原始 BAR：
> 
> ```
> 0000000000000000'00000000'00000000'00010000
> ```
> 
> 写 FFFFFFFF 后读出：
> 
> ```
> 1111111111111111'11111111'11100000'00000000
> ```
> 
> 你看到：
> 
> - bit0–3 被硬件强制改成 0（因为表示类型，不属于 size 域）
>     
> - 真正表示大小的是从 bit4 往上的一串 0
>     
> 
> 因此，尽管有类型位，**mask 测试依然可以正确得到 BAR 大小，不需要特殊处理**。
> 
> ---
> 
> ### 🚩 总结一句话：
> 
> > **BAR mask = 对 BAR 写全 1 后读回的值，它反映了设备硬件中被强制置 0 的位，代表地址窗口大小。  
> > 即便 BAR 有类型位（bit0–3），PCI 硬件在 mask 测试时会把这些位清零，不会影响 size 的计算。**
> 
> ---
> 
> ### 如果你需要，我可以进一步给：
> 
> - BAR 大小计算公式（非常重要）
>     
> - Memory BAR 和 I/O BAR 的 mask 差异
>     
> - 真实 Linux 代码（pci_read_base）解析 BAR mask
>     
> - 用一个实际 NVMe/网卡的示例展示 mask 和 size 关系
>     
> 
> 要看哪一个？
> 
> 先澄清一点：  
> **“读 BAR 大小时写进去 `0xFFFF FFFF` 只是为了让设备“暴露出”哪些位是只读的（硬件返回 0），哪些位是可写的（硬件回显 1）。”**  
> **但 BAR 的低 4 位并不会回显写进去的值，它们被硬件定义为只读属性位，所以读出来永远是 0。**
> 
> 你问的是：
> 
> > “那怎么获取低 4 位的信息，如果读出来一定是 0？”
> 
> 答案：
> 
> ##### **获取 BAR 低 4 位（属性位）不是靠写 FFFF，而是用普通读操作**
> 
> 也就是说：
> 
> - **第一次读 BAR：得到 BAR 的类型信息（低 4 位） + 基地址值（暂时未分配时可能是 0）**
>     
> - **写 0xFFFF FFFF 再读：这个过程仅用于检测可写位从而推断大小，不用于读取低 4 位**
>     
> - **再次写入分配后的地址（必须带上正确的低 4 位属性）**
>     
> 
> ---
> 
> #### ⭐ 正确流程总结（非常关键）
> 
> ##### **步骤 1：普通读 BAR（不用写 FFFF）**
> 
> 目的：得到 BAR 属性，包括低 4 位：
> 
> - bit0 = 0：Memory BAR
>     
> - bit0 = 1：IO BAR
>     
> - bit2:1：Memory 类型（32位/64位/prefetchable）
>     
> - bit3: — reserved
>     
> - bit4 以后：真正的 base address bits（尚未分配时可能为 0）
>     
> 
> 例：  
> 读出来：`0x0000_0004`  
> → 说明是 memory BAR，类型 = 64bit。
> 
> ---
> 
> ##### **步骤 2：写 0xFFFF FFFF（32bit BAR）或 0xFFFF FFFF_ffff FFFF（64bit BAR）**
> 
> ⚠️ 这一写操作只用于让设备暴露出哪些位是可写，从而 **计算大小**。
> 
> 此时低 4 位仍然是只读，硬件会：
> 
> - 内部忽略写入的低 4 位
>     
> - 读出来时返回 0（Memory BAR）或固定格式（I/O BAR）
>     
> 
> 所以 **写 FFFF 用于获取大小，不用于读取属性。**
> 
> ---
> 
> ##### **步骤 3：再次读 BAR，进行 size 探测**
> 
> 读出的值可能是：
> 
> 例如读到：`0xFFFF_F000`  
> → 低 12 位是 0  
> → 表示需要 4K 大小的 space。
> 
> 计算大小：
> 
> ```
> size = ~(read_value & mask) + 1
> ```
> 
> mask 对 Memory BAR 是 `0xFFFF_FFF0`  
> mask 对 IO BAR 是 `0xFFFF_FFFC`
> 
> ---
> 
> ##### **步骤 4：写回 OS 分配的 base address（带低 4 位属性）**
> 
> 低 4 位必须维持最初读到的属性：
> 
> 例子：
> 
> - 第一次读到：`0x0000_0004`
>     
> - 表示：64bit memory BAR，不可预取。
>     
> 
> 分配地址时：
> 
> ```
> write BAR = assigned_address | 0x4
> ```
> 
> ---
> 
> #### ⭐ 回答你的核心问题
> 
> > 为什么写 FFFF 后读出来低 4 位永远是 0？  
> > 那怎么获取低 4 位的信息？
> 
> ##### **原因：**
> 
> BAR 低 4 位是硬件定义的只读属性位，写 FFFF 时**不会被写入**，读出来永远按规范返回固定的值。
> 
> ##### **解决：**
> 
> **低 4 位属性信息只能从“第一次读 BAR”得到，而不是从 size 探测读出。**
> 
> ---
> 
> #### ⭐ 简短版总结（面试官爱问）
> 
> - **第一次读 BAR → 读取 BAR 类型（低 4 位）**
>     
> - **写 FFFF → 让设备告诉你哪些位可写，用于计算大小**
>     
> - **再读 BAR → 用 ~value + 1 推出 size**
>     
> - **分配地址后写回 base | 属性位**
>     
> 
> **BAR 低 4 位永远是第一次读 BAR 才能获得，之后读都不会回显写入的值。**
> 
> ---
> 
> 如果你需要我把 Memory BAR 和 IO BAR 的完整 bit 定义画成表，我可以帮你整理。