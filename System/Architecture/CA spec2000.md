跑spec2000的一些问题：

- 253.perlbmk: 添加`-fgnu89-inline`
- 254.gap: 可能会溢出，添加`-fno-strict-overflow`

---

### 1. `-fno-strict-overflow`

**默认行为**：  
GCC 在优化时，默认认为 **有符号整数不会发生溢出**（因为 C 标准规定有符号溢出是 _undefined behavior_）。  
这意味着编译器可能会基于“不会溢出”的假设进行优化。

**例如**：

```c
int f(int x) {
    return (x+1) > x;
}
```

- 按照数学逻辑，`(x+1) > x` 恒为真。
    
- 但如果 `x == INT_MAX`，会溢出，结果是 `(INT_MIN > INT_MAX)`，为假。
    
- **GCC 默认优化后会直接返回 `1`（真），忽略溢出情况**。
    

**加上 `-fno-strict-overflow` 后**：  
告诉编译器：**不要假设有符号整数不会溢出**，也就是说编译器必须考虑溢出的结果，不能进行这类“恒真/恒假”的优化。

👉 常用于 **安全相关代码** 或 **依赖有符号溢出行为的算法**。

---

### 2. `-fgnu89-inline`

**背景**：  
C 语言里的 `inline` 在不同标准下规则不同：

- **C99 标准**：`inline` 函数默认是 **仅内联，不生成函数定义**，如果需要定义，需要 `extern inline`。
    
- **GNU89/GNU C 扩展**（GCC 默认 C89 模式时的行为）：`inline` 函数既会被内联，也会生成一个普通函数定义（除非显式 `extern inline`）。
    

**问题**：C99 和 GNU89 规则完全相反，容易导致链接错误。

**`-fgnu89-inline` 的作用**：  
强制 GCC 按 **GNU89 的旧规则** 处理 `inline`，而不是 C99/gnu11 的规则。

👉 常用于 **老代码** 或 **依赖 GNU89 内联语义的项目**（比如 Linux 内核）。

