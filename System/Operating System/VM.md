## 空闲内存管理

### 位图

用bitmap每一位表示每一个固定长度的分配单元是否被分配

### 链表

双向链表管理节点

分配方法

- First Fit: 遍历链表，选择第一个块大小 $B\geq$ 分配大小 $M$ 的块，拆成 $M$ 和 $B-M$
- Next Fit: 类似 First Fit, 但从上一次分配的位置继续
- Best Fit: 选择所有满足分配要求的块中大小最小的，问题：内存碎片
- Worst Fit: 最大的，也不是很好。

---

## 分页

页表 Page Table
物理内存页 Page Frame（页框）

---

### TLB

把页表存在寄存器里 (页表的缓存)

---

### 大页表的处理

#### 分级页表

motivation: 完整的页表装不下，没用过的区域也不用装进内存（既然内存可以分页按需加载，那么页表也可以分页）

#### 倒排页表

> 现在没人用了

针对物理内存 $\ll$ 虚拟内存的情况，每个物理内存映射到一个页表项，用哈希表保存虚拟页到物理页的映射

---

### 页面置换

发现页表中没有对应项时，触发缺页 Page Fault，进行页面替换

#### 最优置换

贪心，每次选择下一次访问最晚的页替换掉

#### NRU 最近未使用页面替换

对于某个时间片内，可以把页分为 4 类

1. visit=0, modify=0
2. visit=0, modify=1
3. visit=1, modify=0
4. visit=1, modify=1

(2 是可能发生的，因为可能每个时间片开始时会重置 visit=0，但不会重置 modify)

分类数字越高，替换优先级越低

intuition: 淘汰一个不访问的修改页面比淘汰经常访问的干净页面好

#### FIFO / 第二次机会 FIFO

FIFO: 按进入页表的时间 FIFO

第二次机会：如果准备替换掉这个页表项的时候它之前被访问过了，那么清除访问标记，给它重新放回页表开头，更新装入时间 (如果所有页面都被访问过了，会退化成 FIFO)

#### Clock 时钟

把页表项整理成环形列表，可以选择跳过——按时钟指针方向移动到下一项（相当于FIFO重新入队）或替换

#### LRU 最近最少使用

置换未使用时间最长的页面

比较难实现

#### NFU 最不常用

用计数器记录访问次数，选择次数最少的替换

> [!question]
> 问题：怎么忘记之前的信息？

**Aging**: 每个时钟周期对应计数器的某一位，如果这个时钟周期访问了，就将其置1。具体地，没过一个时钟周期将计数器右移一位，新修改计数器的最高位。

问题：记录历史有限+一个时间片内先后顺序无法区分

#### 朴素工作集页面替换

维护 _工作集_: 最近几次访问的页

最近几次访问比较难统计，按时间统计更方便实现一些，缺页中断的时候判断一下上次访问时间与当前时间的距离（生存时间）是否超过工作集阈值 $\tau$ 即可，超过了 $\implies$ 替换，没超过 $\implies$ 临时记录下生存时间最久的

如果所有的都在工作集中，则选择生存时间最久的，如果所有的生存时间都是 $0$ （当前时间片访问了）那么可以随机选一个，或者最好选干净的替换。

#### 时钟工作集替换

绕页表一圈，异步替换 modify=1 的不在工作集的页面，如果有干净的不在工作集的页面，直接占用这个页表项，否则会完整绕页表一圈，此时：
- 有调度过写操作 $\implies$ 等待某一个替换操作完成，占用那个页框
- 没有调度过写操作 $\implies$ 所有页都在工作集中，如果可能，替换干净页面，否则替换当前页面

---

## 局部分配和全局分配

局部：在进程内部替换页框
全局：可以替换掉一个进程占用的页框给另一个进程用

全局分配时，怎么给不同进程确定页框数？

- 平均分配 | 不行
- 按进程大小分配 | 不能动态分配

最好的方法：用缺页中断率 Page Fault Frequency

有的置换方法不能用全局策略：工作集/工作集时钟